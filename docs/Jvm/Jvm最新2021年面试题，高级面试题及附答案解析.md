# Jvm最新2021年面试题，高级面试题及附答案解析

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://github.com/souyunku/DevBooks/blob/master/docs/index.md)



### 1、为什么需要双亲委派模式？

在这里，先想一下，如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么类之间的比较结果及类的唯一性将无法保证，因此，为什么需要双亲委派模型？防止内存中出现多份同样的字节码。


### 2、类加载器

虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类， JVM 提供了 3 种类加载器：

启动类加载器(Bootstrap ClassLoader)

负责加载 JAVA_HOME\lib 目录中的， 或通过-Xbootclasspath 参数指定路径中的， 且被虚拟机认可（按文件名识别， 如 rt.jar） 的类。

**扩展类加载器(Extension ClassLoader)**

负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。

**应用程序类加载器(Application ClassLoader)：**

负责加载用户路径（classpath）上的类库。JVM 通过双亲委派模型进行类的加载， 当然我们也可以通过继承 java.lang.ClassLoader实现自定义的类加载器。


### 3、请解释StackOverflowError和OutOfMemeryError的区别？

通过之前的分析可以发现，实际上每一块内存中都会存在有一部分的可变伸缩区，其基本流程为：如果空间内存不足，在可变范围之内扩大内存空间，当一段时间之后发现内存充足，会缩小内存空间。

**永久代（JDK 1.8后消失了）**

虽然java的版本是JDK1.8，但是java EE 的版本还是jdk1.7，永久代存在于堆内存之中

**元空间**

元空间在Jdk1.8之后才有的，器功能实际上和永久代没区别，唯一的区别在于永久代使用的是JVM的堆内存空间，元空间使用的是物理内存，所以元空间的大小受本地内存影响，一般默认在2M 左右。

**范例：设置一些参数，让元空间出错**

Java -XX:MetaspaceSize=1m


### 4、你平时工作中用过的JVM常用基本配置参数有哪些？

**-Xms**

初始化大小内存，默认为物理内存1/64

等价于-XX:InitialHeapSize

**-Xmx**

最大分配内存，默认物理内存的1/4

等价于-XX:MaxHeapSize

**-Xss**

设置单个线程栈的大小，一般默认为512K~1024K

等价于-XX:ThreadStackSize

-XX:ThreadStackSize = 0 ， 表示使用默认512K~1024K

-XX:ThreadStackSize != 0 , 表示使用自己设置的

**-Xmn**

设置年轻代大小,一般不需要改动

**-Xms128m -Xmx4096m -Xss1024k -XX:MetaSpaceSize=512m -XX:+PrintCommandFlags -XX:+PrintGCDetails -XX:+UseSerialGC**

**-XX:MetaspaceSize**

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。

不过元空间与永久代之间最大的区别在于：

永久代在堆里面

元空间并不在虚拟机中，而是使用本地内存。

因此，在默认情况下，元空间的大小仅受本地内存限制

eg:

Xms10m -Xmx10m -XX:MetaspaceSize=1024m -XX:+PrintFlagsFinal

初始值约21M，也就是说只占用本地内存的21M，如果你频繁的new对象，有可能就会把元空间撑爆从而发生元空间异常，因此需要调大一些

-XX:+PrintGCDetails

你只需要记忆10个左右即可应付`绝大多数`面试，建议只记忆G1相关参数。CMS这种既耗时间参数又多又被淘汰的东西，不看也罢。面试时间有限，不会在这上面纠结，除非你表现的太嚣张了。


### 5、ZGC 了解吗？

JDK11 中加入的具有实验性质的低延迟垃圾收集器，目标是尽可能在不影响吞吐量的前提下，实现在任意堆内存大小都可以把停顿时间限制在 10ms 以内的低延迟。

基于 Region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记-整理，以低延迟为首要目标。

ZGC 的 Region 具有动态性，是动态创建和销毁的，并且容量大小也是动态变化的。


### 6、栈帧里面包含哪些东西？

局部变量表、操作数栈、动态连接、返回地址等


### 7、简单描述一下（分代）垃圾回收的过程

分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 `1/3`，老生代的默认占比是 `2/3`。

新生代使用的是复制算法，新生代里有 3 个分区：`Eden`、`To Survivor`、`From Survivor`，它们的默认占比是 `8:1:1`，它的执行流程如下：

**当年轻代中的Eden区分配满的时候，就会触发年轻代的GC（Minor GC）。具体过程如下：**

**1、** 在Eden区执行了 `第一次`GC之后，存活的对象会被移动到其中一个Survivor分区（以下简称from）

**2、** Eden区再次GC，这时会采用复制算法，将Eden和from区一起清理。存活的对象会被复制到to区。接下来，只需要清空from区就可以了


### 8、分区收集算法
### 9、运行时常量池溢出的原因？
### 10、什么情况下会发生栈溢出？
### 11、JVM 监控与分析工具你用过哪些？介绍一下。
### 12、谈谈永久代
### 13、JVM 的内存模型以及分区情况和作用
### 14、说说线程栈
### 15、Java会存在内存泄漏吗？请简单描述。
### 16、创建对象的过程是什么？
### 17、分代回收
### 18、被引用的对象就一定能存活吗？
### 19、对象分配内存是否线程安全？
### 20、什么是指令重排序？
### 21、JVM垃圾回收机制，何时触发MinorGC等操作
### 22、Java 内存分配与回收策率以及 Minor GC 和 Major GC
### 23、Serial 垃圾收集器（单线程、 复制算法）
### 24、在老年代-标记整理算法
### 25、JIT 是什么？
### 26、Java 中会存在内存泄漏?简述一下
### 27、直接内存是什么？
### 28、你知道哪些故障处理工具？
### 29、说说类加载的过程
### 30、什么是逃逸分析？
### 31、JVM垃圾回收时候如何确定垃圾？什么是GC Roots？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)




## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
