# MySQL最新面试题及答案附答案汇总

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://github.com/souyunku/DevBooks/blob/master/docs/index.md)



### 1、MySQL中有哪些不同的表格？

**共有5种类型的表格：**

**1、** MyISAM

**2、** Heap

**3、** Merge

**4、** INNODB

**5、** ISAM


### 2、MySQL 遇到过死锁问题吗，你是如何解决的？

我排查死锁的一般步骤是酱紫的：

**1、** 查看死锁日志show engine innodb status;

**2、** 找出死锁Sql

**3、** 分析sql加锁情况

**4、** 模拟死锁案发

**5、** 分析死锁日志

**6、** 分析死锁结果


### 3、MySQL中int(20)和char(20)以及varchar(20)的区别

**1、** int(20) 表示字段是int类型，显示长度是 20

**2、** char(20)表示字段是固定长度字符串，长度为 20

**3、** varchar(20) 表示字段是可变长度字符串，长度为 20


### 4、什么是数据库事务？

数据库事务（简称：事务），是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。


### 5、MYSQL支持事务吗？

在缺省模式下，MYSQL是autocommit模式的，所有的数据库更新操作都会即时提交，所以在缺省情况下，MySQL是不支持事务的。

但是如果你的MYSQL表类型是使用InnoDB Tables 或 BDB tables的话，你的MYSQL就可以使用事务处理,使用SET

AUTOCOMMIT=0就可以使MYSQL允许在非autocommit模式，在非autocommit模式下，你必须使用COMMIT来提交你的更改，或者用ROLLBACK来回滚你的更改。


### 6、索引的数据结构（b树，hash）

索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有**Hash索引**，**B+树索引**等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

**B树索引**

MySQL通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是MySQL数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，MySQL一律打印BTREE，所以简称为B树索引）

![99_1.png][99_1.png]

**查询方式：**

**1、** 主键索引区:PI(关联保存的时数据的地址)按主键查询,

**2、** 普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快

**B+tree性质：**

**1、** n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。

**2、** 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

**3、** 所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。

**4、** B+ 树中，数据对象的插入和删除仅在叶节点上进行。

**5、** B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。

**哈希索引**

简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在MySQL中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。

![99_2.png][99_2.png]


### 7、什么是幻读，脏读，不可重复读呢？

**1、** 事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是「脏读」

**2、** 在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是「不可重复读」。

**3、** 事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是「幻读」。


### 8、B树和B+树的区别，数据库为什么使用B+树而不是B树？

在B树中，键和值即存放在内部节点又存放在叶子节点；在B+树中，内部节点只存键，叶子节点则同时存放键和值。

B+树的叶子节点有一条链相连，而B树的叶子节点各自独立的。

B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。.

B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快.


### 9、创建索引的三种方式

**第一种方式：**在执行CREATE TABLE时创建索引

```
CREATE TABLE user\_index2 ( id INT auto\_increment PRIMARY KEY, first\_name VARCHAR (16), last\_name VARCHAR (16), id\_card VARCHAR (18), information text, KEY name (first\_name, last\_name), FULLTEXT KEY (information), UNIQUE KEY (id\_card) );
```

**第二种方式：**使用ALTER TABLE命令去增加索引

```
ALTER TABLE table_name ADD INDEX index_name (column_list);
```

**1、** ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。

**2、** 其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。

**3、** 索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。

**4、** 第三种方式：使用CREATE INDEX命令创建

```
CREATE INDEX index_name ON table_name (column_list);
```

CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）


### 10、数据库索引的原理，为什么要用 B+树，为什么不用二叉树？

可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，而偏偏是B+树呢？

**为什么不是一般二叉树？**

如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。

**为什么不是平衡二叉树呢？**

我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。

**那为什么不是B树而是B+树呢？**

1）B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。

2）B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。


### 11、MySQL中有哪些不同的表格？
### 12、Blob和text有什么区别？
### 13、什么是游标？
### 14、SQL 约束有哪几种呢？
### 15、说出一些数据库优化方面的经验?
### 16、字段为什么要求定义为not null？
### 17、日常工作中你是怎么优化SQL的？
### 18、什么是触发器？触发器的使用场景有哪些？
### 19、可以使用多少列创建索引？
### 20、MySQL_fetch_array和MySQL_fetch_object的区别是什么？
### 21、存储引擎选择
### 22、B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？
### 23、MySQL一条SQL加锁分析
### 24、列的字符串类型可以是什么？
### 25、为什么索引结构默认使用B+Tree，而不是Hash，二叉树，红黑树？
### 26、MySQL有哪些数据类型
### 27、覆盖索引、回表等这些，了解过吗？
### 28、百万级别或以上的数据，你是如何删除的？
### 29、存储时期
### 30、UNION与UNION ALL的区别？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)




## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
