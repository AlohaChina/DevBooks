# 前端面试题及答案整理，2021年最新，汇总版

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://github.com/souyunku/DevBooks/blob/master/docs/index.md)



### 1、Flex布局

[juejin.im/post/5d428c…][juejin.im_post_5d428c]


### 2、那些操作会造成内存泄漏？

内存泄漏指任何对象在您不再拥有或需要它之后仍然存在

`setTimeout` 的第一个参数使用字符串而非函数的话，会引发内存泄漏

闭包使用不当


### 3、与深拷贝有何区别？如何实现？

**浅拷贝只复制指向某个对象的指针，而不复制对象本身。浅拷贝的实现方式有：**

**1、** `Object.assign()`：需注意的是目标对象只有一层的时候，是深拷贝；

**2、** 扩展运算符；

**深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。深拷贝的实现方式有：**

**1、** 手写遍历递归赋值；

**2、** 结合使用`JSON.parse()`和`JSON.stringify()`方法。


### 4、new 关键字有什么作用？

`new`关键字与构造函数一起使用以创建对象:

```
function Employee(name, position, yearHired) {
  this.name = name;
  this.position = position;
  this.yearHired = yearHired;
};

const emp = new Employee("Marko Polo", "Software Developer", 2017);
```

`new`关键字做了`4`件事:

**1、** 创建空对象 `{}`

**2、** 将空对象分配给 `this` 值

**3、** 将空对象的`__proto__`指向构造函数的`prototype`

**4、** 如果没有使用显式`return`语句，则返回`this`

看下面事例：

`function Person() { this.name = 'kyle' }`

根据上面描述的，`new Person()`做了：

**1、** 创建一个空对象：`var obj = {}`

**2、** 将空对象分配给 `this` 值：this = obj

**3、** 将空对象的`__proto__`指向构造函数的`prototype`:`this.__proto__ = Person().prototype`

**4、** 返回`this`:`return this`



### 5、webSocket如何兼容低浏览器？(阿里)

**1、** Adobe Flash Socket

**2、** ActiveX HTMLFile (IE)

**3、** 基于 multipart 编码发送 XHR

**4、** 基于长轮询的 XHR


### 6、常见的浏览器内核有哪些

**1、** Trident( MSHTML )：IE MaxThon TT The World 360 搜狗浏览器

**2、** Geckos：Netscape6及以上版本 FireFox Mozilla Suite/SeaMonkey

**3、** Presto：Opera7及以上(Opera内核原为：Presto，现为：Blink)

**4、** Webkit：Safari Chrome


### 7、window.onload ==? DOMContentLoaded ?

一般情况下，DOMContentLoaded事件要在window.onload之前执行，当DOM树构建完成的时候就会执行DOMContentLoaded事件，而window.onload是在页面载入完成的时候，才执行，这其中包括图片等元素。大多数时候我们只是想在DOM树构建完成后，绑定事件到元素，我们并不需要图片元素，加上有时候加载外域图片的速度非常缓慢。


### 8、事件流?事件捕获？事件冒泡？

**事件流：**

从页面中接收事件的顺序。也就是说当一个事件产生时，这个事件的传播过程，就是事件流。

IE中的事件流叫事件冒泡；

事件冒泡：

事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档）。对于html来说，就是当一个元素产生了一个事件，它会把这个事件传递给它的父元素，父元素接收到了之后，还要继续传递给它的上一级元素，就这样一直传播到document对象（亲测现在的浏览器到window对象，只有IE8及下不这样

事件捕获是不太具体的元素应该更早接受到事件，而最具体的节点应该最后接收到事件。他们的用意是在事件到达目标之前就捕获它；也就是跟冒泡的过程正好相反，以html的click事件为例，document对象（DOM级规范要求从document开始传播，但是现在的浏览器是从window对象开始的）最先接收到click事件的然后事件沿着DOM树依次向下传播，一直传播到事件的实际目标；


### 9、什么是 event.target ？

简单来说，`event.target`是发生事件的元素或触发事件的元素。

假设有如下的 HTML 结构：

```
<div onclick="clickFunc(event)" style="text-align: center;margin:15px;
border:1px solid red;border-radius:3px;">
    <div style="margin: 25px; border:1px solid royalblue;border-radius:3px;">
        <div style="margin:25px;border:1px solid skyblue;border-radius:3px;">
          <button style="margin:10px">
             Button
          </button>
        </div>
    </div>
 </div>
```

JS 代码如下：

```
function clickFunc(event) {
  console.log(event.target);
}
```

如果单击 `button`，即使我们将事件附加在最外面的`div`上，它也将打印 `button` 标签，因此我们可以得出结论`event.target`是触发事件的元素。


### 10、什么是事件冒泡？

当**事件**发生在**DOM**元素上时，该**事件**并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达`window`为止。

假设有如下的 HTML 结构：

```
<div class="grandparent">
  <div class="parent">
    <div class="child">1</div>
  </div>
</div>
```

对应的 JS 代码:

```
function addEvent(el, event, callback, isCapture = false) {
  if (!el || !event || !callback || typeof callback !== 'function') return;
  if (typeof el === 'string') {
    el = document.querySelector(el);
  };
  el.addEventListener(event, callback, isCapture);
}

addEvent(document, 'DOMContentLoaded', () => {
  const child = document.querySelector('.child');
  const parent = document.querySelector('.parent');
  const grandparent = document.querySelector('.grandparent');

  addEvent(child, 'click', function (e) {
    console.log('child');
  });

  addEvent(parent, 'click', function (e) {
    console.log('parent');
  });

  addEvent(grandparent, 'click', function (e) {
    console.log('grandparent');
  });

  addEvent(document, 'click', function (e) {
    console.log('document');
  });

  addEvent('html', 'click', function (e) {
    console.log('html');
  })

  addEvent(window, 'click', function (e) {
    console.log('window');
  })

});
```

`addEventListener`方法具有第三个可选参数`useCapture`，其默认值为`false`，事件将在冒泡阶段中发生，如果为`true`，则事件将在捕获阶段中发生。如果单击`child`元素，它将分别在控制台上记录`child`，`parent`，`grandparent`，`html`，`document`和`window`，这就是事件冒泡。


### 11、请解释一下CSS3的flexbox（弹性盒布局模型）,以及适用场景？
### 12、拖放API：drag、drop
### 13、xhtml和html有什么区别?
### 14、你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?
### 15、DOCTYPE有什么作用？标准模式与混杂模式如何区分？它们有何意义?
### 16、浏览器是怎样解析CSS选择器的？
### 17、html和xhtml有什么区别?
### 18、那些操作会造成内存泄漏？
### 19、JavaScript有几种类型的值？，你能画一下他们的内存图吗？
### 20、spa应用
### 21、标准模式与兼容模式各有什么区别？
### 22、JSON 的了解？
### 23、如何在页面上实现一个圆形的可点击区域？
### 24、介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？
### 25、让页面里的字体变清晰，变细用CSS怎么做？
### 26、谈一下你对网页标准和标准制定机构重要性的理解。
### 27、promise###
### 28、Jq绑定事件的几种方式？on bind ?
### 29、什么是包装对象（wrapper object）？
### 30、`link`与`@import`的区别




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)




## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
