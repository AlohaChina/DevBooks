# 并发编程高级面试题及答案，2021版

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)



### 1、并发编程三个必要因素是什么？

**原子性：**

原子，即一个不可再被分割的颗粒。原子性指的是一个或多个操作要么全部执行成功要么全部执行失败。

**可见性：**

一个线程对共享变量的修改,另一个线程能够立刻看到。（synchronized,volatile）

**有序性：**

程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）


### 2、Java 内存分配与回收策率以及 Minor GC 和 Major GC

**1、** 对象优先在堆的 Eden 区分配

**2、** 大对象直接进入老年代

**3、** 长期存活的对象将直接进入老年代

当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC。Minor GC 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快；Full GC/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC，但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。


### 3、线程的状态

**1、** 新建(new)：新创建了一个线程对象。

**2、** 就绪（可运行状态）(runnable)：线程对象创建后，当调用线程对象的 start()方法，该线程处于就绪状态，等待被线程调度选中，获取cpu的使用权。

**3、** 运行(running)：可运行状态(runnable)的线程获得了cpu时间片（timeslice），执行程序代码。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；

**4、** 阻塞(block)：处于运行状态中的线程由于某种原因，暂时放弃对 CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被 CPU 调用以进入到运行状态。

**阻塞的情况分三种：**

**1、** 等待阻塞：

运行状态中的线程执行 wait()方法，JVM会把该线程放入等待队列(waitting queue)中，使本线程进入到等待阻塞状态；

**2、** 同步阻塞：

线程在获取 synchronized 同步锁失败(因为锁被其它线程所占用)，，则JVM会把该线程放入锁池(lock pool)中，线程会进入同步阻塞状态；

**3、** 其他阻塞:

通过调用线程的 sleep()或 join()或发出了 I/O 请求时，线程会进入到阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。

**4、** 死亡(dead)(结束)：

线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。


### 4、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？

**双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。**

**1、** 假设有一个开发者自己编写了一个名为`java.lang.Object`的类，想借此欺骗JVM。现在他要使用自定义`ClassLoader`来加载自己编写的`java.lang.Object`类。

**2、** 然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在`Bootstrap ClassLoader`的路径下找到`java.lang.Object`类，并载入它

Java的类加载是否一定遵循双亲委托模型？

**1、** 在实际开发中，我们可以通过自定义ClassLoader，并重写父类的loadClass方法，来打破这一机制。

**2、** SPI就是打破了双亲委托机制的(SPI：服务提供发现)。


### 5、CopyOnWriteArrayList 的设计思想?

**1、** 读写分离，读和写分开

**2、** 最终一致性

**3、** 使用另外开辟空间的思路，来解决并发冲突


### 6、Serial 与 Parallel GC 之间的不同之处？

Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行。


### 7、如何判断对象可以被回收

判断对象是否存活一般有两种方式：

引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。

可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。


### 8、你对线程优先级的理解是什么？

**1、** 每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从 1-10)，1 代表最低优先级，10 代表最高优先级。

**2、** Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。

**3、** 当然，如果你真的想设置优先级可以通过setPriority()方法设置，但是设置了不一定会该变，这个是不准确的


### 9、为什么要使用并发编程

**1、** 提升多核CPU的利用率：一般来说一台主机上的会有多个CPU核心，我们可以创建多个线程，理论上讲操作系统可以将多个线程分配给不同的CPU去执行，每个CPU执行一个线程，这样就提高了CPU的使用效率，如果使用单线程就只能有一个CPU核心被使用。

**2、** 比如当我们在网上购物时，为了提升响应速度，需要拆分，减库存，生成订单等等这些操作，就可以进行拆分利用多线程的技术完成。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。

**简单来说就是：**

**1、** 充分利用多核CPU的计算能力；

**2、** 方便进行业务拆分，提升应用性能


### 10、Java 中堆和栈有什么区别？

JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。


### 11、java中会存在内存泄漏吗，请简单描述。
### 12、如何自定义线程线程池?
### 13、JAVA弱引用
### 14、什么是多线程中的上下文切换？
### 15、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？
### 16、什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？
### 17、说下有哪些类加载器？
### 18、Collections.synchronized  是什么？
### 19、在新生代-复制算法
### 20、如果你提交任务时，线程池队列已满，这时会发生什么
### 21、方法区的作用是什么？
### 22、final不可变对象，它对写并发应用有什么帮助？
### 23、线程池有什么优点？
### 24、请你谈谈对OOM的认识
### 25、Java 中你怎样唤醒一个阻塞的线程？
### 26、什么叫线程安全？servlet是线程安全吗?
### 27、四种线程池的创建：
### 28、Java 线程数过多会造成什么异常？
### 29、如何停止一个正在运行的线程？
### 30、创建线程的三种方式的对比？
### 31、你知道哪些故障处理工具？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "大厂面试题")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png"大厂面试题")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
