# 并发编程最新面试题及答案附答案汇总

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)



### 1、重排序实际执行的指令步骤

![87_5.png][87_5.png]

**1、** 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。

**2、** 指令级并行的重排序。现代处理器采用了指令级并行技术（ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

**3、** 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

这些重排序对于单线程没问题，但是多线程都可能会导致多线程程序出现内存可见性问题。


### 2、如何判断一个对象是否存活

**判断一个对象是否存活有两种方法：**

**1、** 引用计数法

所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收、

引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B，对象 B 又引用者对象 A，那么此时 A、B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。

**2、** 可达性算法（引用链法）

该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。

**在 Java 中可以作为 GC Roots 的对象有以下几种：**

**1、** 虚拟机栈中引用的对象

**2、** 方法区类静态属性引用的对象

**3、** 方法区常量池引用的对象

**4、** 本地方法栈JNI引用的对象

虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达 GC Root 时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记、

如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除” 即将回收” 集合，等待回收。


### 3、newScheduledThreadPool

**特点**：

创建一个固定长度的线程池，而且支持定时的以及周期性的任务执行，类似于Timer（Timer是Java的一个定时器类）

**缺点**：由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务（比如：一个任务出错，以后的任务都无法继续）。

#
### 4、Java的双亲委托机制是什么？

它的意思是，除了顶层的启动类加载器以外，其余的类加载器，在加载之前，都会委派给它的父加载器进行加载。这样一层层向上传递，直到祖先们都无法胜任，它才会真正的加载。

Java默认是这种行为。当然Java中也有很多打破双亲行为的骚操作，比如SPI（JDBC驱动加载），OSGI等。


### 5、同步方法和同步块，哪个是更好的选择？

同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。

同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。

`请知道一条原则：同步的范围越小越好。`


### 6、AQS支持两种同步方式：

**1、** 独占式

**2、** 共享式

这样方便使用者实现不同类型的同步组件，独占式如ReentrantLock，共享式如Semaphore，CountDownLatch，组合式的如ReentrantReadWriteLock。总之，AQS为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。


### 7、怎么判断并发队列是阻塞队列还是非阻塞队列

在并发队列上JDK提供了Queue接口，一个是以Queue接口下的BlockingQueue接口为代表的阻塞队列，另一个是高性能（无堵塞）队列。


### 8、invokedynamic指令是干什么的？

属于比较高级的题目。没看过虚拟机的一般是不知道的。所以如果你不太熟悉，不要气馁，加油！（小拳拳锤你胸口）。

`invokedynamic`是`Java7`之后新加入的字节码指令，使用它可以实现一些动态类型语言的功能。我们使用的Lambda表达式，在字节码上就是invokedynamic指令实现的。它的功能有点类似反射，但它是使用方法句柄实现的，执行效率更高。


### 9、JAVA软引用

软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。


### 10、精确来说的话的话：

**从以下几个角度分析任务的特性：**

**1、** 任务的性质：CPU密集型任务、IO密集型任务、混合型任务。

**2、** 任务的优先级：高、中、低。

**3、** 任务的执行时间：长、中、短。

**4、** 任务的依赖性：是否依赖其他系统资源，如数据库连接等。

**可以得出一个结论：**

**1、** 线程等待时间比CPU执行时间比例越高，需要越多线程。

**2、** 线程CPU执行时间比等待时间比例越高，需要越少线程。


### 11、newCachedThreadPool
### 12、谈谈 JVM 中的常量池
### 13、如何判断两个类是否相等？
### 14、堵塞队列：
### 15、谈谈你知道的垃圾回收算法
### 16、说说类加载的过程
### 17、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？
### 18、说一下 synchronized 底层实现原理？
### 19、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？
### 20、栈帧都有哪些数据？
### 21、什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？
### 22、线程B怎么知道线程A修改了变量
### 23、并发编程有什么缺点
### 24、Serial Old 收集器（单线程标记整理算法 ）
### 25、为什么 Thread 类的 sleep()和 yield ()方法是静态的？
### 26、G1 收集器
### 27、什么是Java Timer 类？如何创建一个有特定时间间隔的任务？
### 28、多线程的常用方法
### 29、为什么HashTable是线程安全的？
### 30、JIT 是什么？
### 31、SWAP会影响性能么？
### 32、多线程中 synchronized 锁升级的原理是什么？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "大厂面试题")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png"大厂面试题")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
