# 并发编程最新面试题及答案整理，汇总版

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://github.com/souyunku/DevBooks/blob/master/docs/index.md)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png)



### 1、死锁的原因

**1、** 是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环。

例如：线程在获得了锁A并且没有释放的情况下去申请锁B，这时，另一个线程已经获得了锁B，在释放锁B之前又要先获得锁A，因此闭环发生，陷入死锁循环。

**2、** 默认的锁申请操作是阻塞的。

所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。总之是尽量避免在一个同步方法中调用其它对象的延时方法和同步方法。


### 2、怎么看死锁的线程？

通过jstack命令，可以获得线程的栈信息。死锁信息会在非常明显的位置（一般是最后）进行提示。


### 3、多线程同步和互斥有几种实现方法，都是什么？

**1、** 线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。

**2、** 线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。

**1、** 线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。

**2、** 用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。


### 4、如何停止一个正在运行的线程？

在java中有以下3种方法可以终止正在运行的线程：

**1、** 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。

**2、** 使用stop方法强行终止，但是不推荐这个方法，因为stop和suspend及resume一样都是过期作废的方法。

**3、** 使用interrupt方法中断线程。


### 5、JVM内存模型

线程独占:栈,本地方法栈,程序计数器

线程共享:堆,方法区


### 6、什么是方法区

用于存储虚拟机加载的类信息，常量，静态变量等数据。


### 7、描述一下什么情况下，对象会从年轻代进入老年代

**1、** 对象的年龄超过一定阀值，-XX:MaxTenuringThreshold 可以指定该阀值

**2、** 动态对象年龄判定，有的垃圾回收算法，比如 G1，并不要求 age 必须达到 15 才能晋升到老年代，它会使用一些动态的计算方法

**3、** 大小超出某个阀值的对象将直接在老年代上分配，值默认为 0，意思是全部首选 Eden 区进行分配，-XX:PretenureSizeThreshold 可以指定该阀值，部分收集器不支持

**4、** 分配担保，当 Survivor 空间不够的时候，则需要依赖其他内存（指老年代）进行分配担保，这个时候，对象也会直接在老年代上分配


### 8、单例模式的线程安全性

老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。

**单例模式有很多种的写法，我总结一下：**

**1、** 饿汉式单例模式的写法：线程安全

**2、** 懒汉式单例模式的写法：非线程安全

**3、** 双检锁单例模式的写法：线程安全


### 9、synchronized和ReentrantLock的区别

synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：

**1、** ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁

**2、** ReentrantLock可以获取各种锁的信息

**3、** ReentrantLock可以灵活地实现多路通知

另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。


### 10、你知道哪些GC类型？

Minor GC：发生在年轻代的 GC。Major GC：发生在老年代的 GC。Full GC：全堆垃圾回收。比如 Metaspace 区引起年轻代和老年代的回收。


### 11、Java 中 interrupted 和 isInterrupted 方法的区别？
### 12、什么是线程池？有哪几种创建方式？
### 13、ArrayList和Vector有什么不同之处？
### 14、Java 中堆和栈有什么区别？
### 15、线程之间如何通信及线程之间如何同步
### 16、有哪些类加载器？
### 17、什么是内存屏障？
### 18、什么是 CAS
### 19、JVM怎么判断一个对象是不是要回收？
### 20、Thread 类中的 yield 方法有什么作用？
### 21、Java中用到的线程调度算法是什么？
### 22、CopyOnWriteArrayList 的设计思想?
### 23、介绍一下类文件结构吧！
### 24、死锁与活锁的区别，死锁与饥饿的区别？
### 25、newCachedThreadPool
### 26、JVM 运行时内存
### 27、线程池四种创建方式？
### 28、本地方法栈的作用？
### 29、Java 程序是怎样运行的？
### 30、为什么使用Executor框架？
### 31、62、volatile 变量和 atomic 变量有什么不同？
### 32、谈谈JVM中，对类加载器的认识




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
