# 并发编程最新面试题及答案整理，汇总版

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)



### 1、用Java实现阻塞队列

参考java中的阻塞队列的内容吧，直接实现有点烦：

[http://www.infoq.com/cn/articles/java-blocking-queue](http://www.infoq.com/cn/articles/java-blocking-queue)


### 2、为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？

当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。

但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。


### 3、模块化编程与热插拔

OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性。

OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。


### 4、死锁与活锁的区别，死锁与饥饿的区别？

死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

**产生死锁的必要条件**：

**1、** 互斥条件：所谓互斥就是进程在某一时间内独占资源。

**2、** 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

**3、** 不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。

**4、** 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

**活锁**：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。

活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。

**饥饿**：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。

**Java中导致饥饿的原因**：

**1、** 高优先级线程吞噬所有的低优先级线程的CPU时间。

**2、** 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。

**3、** 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。


### 5、Java内存模型

共享内存模型指的就是Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入时,能对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：

**1、** 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。

**2、** 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。

**下面通过示意图来说明线程之间的通信**

**总结：什么是Java内存模型：**

java内存模型简称jmm，定义了一个线程对另一个线程可见。共享变量存放在主内存中，每个线程都有自己的本地内存，当多个线程同时访问一个数据的时候，可能本地内存没有及时刷新到主内存，所以就会发生线程安全问题。


### 6、同步方法和同步块，哪个是更好的选择?

同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。


### 7、说说 JVM 如何执行 class 中的字节码。

**1、** JVM 先加载包含字节码的 class 文件，存放在方法区，实际运行时，虚拟机会执行方法区内的代码。Java 虚拟机在内存中划分出栈和堆来存储运行时的数据。

**2、** 运行过程中，每当调用进入 Java 方法，都会在 Java 方法栈中生成一个栈帧，用来支持虚拟机进行方法的调用与执行，包含了局部变量表、操作数栈、动态链接、方法返回地址等信息。

**3、** 当退出当前执行的方法时，不管正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。

**4、** 方法的调用，需要通过解析完成符号引用到直接引用；通过分派完成动态找到被调用的方法。

**5、** 从硬件角度来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器码。翻译过程由两种形式：第一种是解释执行，即将遇到的字节一边码翻译成机器码一边执行；第二种是即时编译(Just-In-Time compilation,JIT)，即将一个方法中包含的所有字节码编译成机器码后再执行。在 HotSpot 里两者都有，解释执行在启动时节约编译时间执行速度较快；随着时间的推移，编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率。


### 8、JVM 有哪些运行时内存区域？

**Java 8**

**1、** The pc Register，程序计数器

**2、** Java Virtual Machine Stacks，Java 虚拟机栈

**3、** Heap，堆

**4、** Method Area，方法区

**5、** Run-Time Constant Pool，运行时常量池

**6、** Native Method Stacks，本地方法栈


### 9、as-if-serial规则和happens-before规则的区别

**1、** as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。

**2、** as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。

**3、** as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。


### 10、方法区

又称非堆区,用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器优化后的代码等数据.1.7的永久代和1.8的元空间都是方法区的一种实现。


### 11、说一下 runnable 和 callable 有什么区别
### 12、多线程的劣势：
### 13、synchronized和ReentrantLock的区别
### 14、对象在哪块内存分配？
### 15、为什么使用Executor框架比使用应用创建和管理线程好？
### 16、GC日志的real、user、sys是什么意思？
### 17、sleep() 和 wait() 有什么区别？
### 18、如何让正在运行的线程暂停一段时间？
### 19、分代收集算法
### 20、Java 虚拟机栈的作用？
### 21、什么是线程同步和线程互斥，有哪几种实现方式？
### 22、如何创建守护线程？
### 23、Java 中 ConcurrentHashMap 的并发度是什么？
### 24、JVM有哪些内存区域？(JVM的内存布局是什么？)
### 25、类加载器双亲委派模型机制？
### 26、线程的调度策略
### 27、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？
### 28、堆（Heap-线程共享） -运行时数据区
### 29、为什么需要双亲委派模式？
### 30、什么是重排序
### 31、Semaphore有什么作用
### 32、Java的内存模型是什么？（JMM是什么？）




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "大厂面试题")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png"大厂面试题")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
