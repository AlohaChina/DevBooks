# 并发编程最新面试题及答案整理，汇总版

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://github.com/souyunku/DevBooks/blob/master/docs/index.md)



### 1、Java中用到的线程调度算法是什么

抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。


### 2、介绍一下类文件结构吧！

魔数: 确定这个文件是否为一个能被虚拟机接收的 Class 文件。Class 文件版本 ：Class 文件的版本号，保证编译正常执行。常量池 ：常量池主要存放两大常量：字面量和符号引用。访问标志 ：标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。当前类索引,父类索引 ：类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。接口索引集合 ：接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implents(如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。字段表集合 ：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。方法表集合 ：类中的方法。属性表集合 ：在 Class 文件，字段表，方法表中都可以携带自己的属性表集合。


### 3、分代回收

分代回收基于两个事实:大部分对象很快就不使用了,还有一部分不会立即无用,但也不会持续很长时间

年轻代->标记-复制

老年代->标记-清除


### 4、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？

阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。

这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。

阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。

**JDK7提供了7个阻塞队列。分别是**：

**1、** ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。

**2、** LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。

**3、** PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。

**4、** DelayQueue：一个使用优先级队列实现的无界阻塞队列。

**5、** SynchronousQueue：一个不存储元素的阻塞队列。

**6、** LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。

**7、** LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

**1、** Java 5之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized这些关键字。而在java 5之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。

**2、** BlockingQueue接口是Queue的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中放入元素，取出元素，它可以很好的控制线程之间的通信。

阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。


### 5、四种线程池的创建：

**1、** newCachedThreadPool创建一个可缓存线程池

**2、** newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数。

**3、** newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。

**4、** newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务。


### 6、Java 内存分配

寄存器：我们无法控制。

静态域：static定义的静态成员。

常量池：编译时被确定并保存在 .class 文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）。

非 RAM 存储：硬盘等永久存储空间。

堆内存：new 创建的对象和数组，由 Java 虚拟机自动垃圾回收器管理,存取速度慢。

栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性。


### 7、Java 的引用有哪些类型？

JDK1.2 后对引用进行了扩充，按强度分为四种：

**强引用：** 最常见的引用，例如 `Object obj = new Object()` 就属于强引用。只要对象有强引用指向且 GC Roots 可达，在内存回收时即使濒临内存耗尽也不会被回收。

**软引用：** 弱于强引用，描述非必需对象。在系统将发生内存溢出前，会把软引用关联的对象加入回收范围以获得更多内存空间。用来缓存服务器中间计算结果及不需要实时保存的用户行为等。

**弱引用：** 弱于软引用，描述非必需对象。弱引用关联的对象只能生存到下次 YGC 前，当垃圾收集器开始工作时无论当前内存是否足够都会回收只被弱引用关联的对象。由于 YGC 具有不确定性，因此弱引用何时被回收也不确定。

**虚引用：** 最弱的引用，定义完成后无法通过该引用获取对象。唯一目的就是为了能在对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用，垃圾回收时如果出现虚引用，就会在回收对象前把这个虚引用加入引用队列。


### 8、什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？

原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。

处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。

在Java中可以通过锁和循环CAS的方式来实现原子操作。 CAS操作——Compare & Set，或是 Compare & Swap，现在几乎所有的CPU指令都支持CAS的原子操作。

原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。

int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。

为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。

java.util.concurrent这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。

原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference

原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray

原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater

解决ABA问题的原子类：AtomicMarkableReference（通过引入一个boolean来反映中间有没有变过），AtomicStampedReference（通过引入一个int来累加来反映中间有没有变过）


### 9、Minor Gc和Full GC 有什么不同呢？

大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。新生代GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。老年代GC（Major GC/Full GC）:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。


### 10、Java中垃圾回收有什么目的？什么时候进行垃圾回收？

**1、** 垃圾回收是在内存中存在没有引用的对象或超过作用域的对象时进行的。

**2、** 垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。


### 11、如何确保线程安全？
### 12、什么是双亲委派机制？
### 13、多线程的价值？
### 14、被引用的对象就一定能存活吗？
### 15、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
### 16、Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？
### 17、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？
### 18、线程与进程的区别？
### 19、stackoverflow错误，permgen space错误
### 20、老年代
### 21、描述一下什么情况下，对象会从年轻代进入老年代
### 22、对象在哪块内存分配？
### 23、在 Java 中，对象什么时候可以被垃圾回收？
### 24、Java 中用到的线程调度算法是什么？
### 25、什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing )？
### 26、32、volatile关键字的原理是什么？干什么用的？
### 27、死锁与活锁的区别，死锁与饥饿的区别？
### 28、java中有几种方法可以实现一个线程？
### 29、怎么获取 Java 程序使用的内存？堆使用的百分比？
### 30、什么是阻塞式方法？
### 31、什么是内存屏障？
### 32、强引用、软引用、弱引用、虚引用是什么，有什么区别？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)




## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
