# 并发编程高级面试题整理及答案

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)



### 1、什么是阻塞式方法？

阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。


### 2、老年代与标记复制算法

**而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。**

**1、** JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)， 它用来存储 class 类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。

**2、** 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。

**3、** 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后， EdenSpace 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 FromSpace 进行清理。

**4、** 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。

**5、** 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。

**6、** 当对象在 Survivor 去躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。


### 3、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？

对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。通常，GC 采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为“不可达”时，GC 就有责任回收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。


### 4、直接内存是什么？

直接内存不属于运行时数据区，也不是虚拟机规范定义的内存区域，但这部分内存被频繁使用，而且可能导致内存溢出。

JDK1.4 中新加入了 NIO 这种基于通道与缓冲区的 IO，它可以使用 Native 函数库直接分配堆外内存，通过一个堆里的 DirectByteBuffer 对象作为内存的引用进行操作，避免了在 Java 堆和 Native堆来回复制数据。

直接内存的分配不受 Java 堆大小的限制，但还是会受到本机总内存及处理器寻址空间限制，一般配置虚拟机参数时会根据实际内存设置 `-Xmx` 等参数信息，但经常忽略直接内存，使内存区域总和大于物理内存限制，导致动态扩展时出现 OOM。

由直接内存导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看见明显的异常，如果发现内存溢出后产生的 Dump 文件很小，而程序中又直接或间接使用了直接内存（典型的间接使用就是 NIO），那么就可以考虑检查直接内存方面的原因。


### 5、能够找到 Reference Chain 的对象，就一定会存活么？

这不一定，还要看reference类型。弱引用会在GC时会被回收，软引用会在内存不足的时候被回收。但没有Reference Chain的对象就一定会被回收。


### 6、类的实例化顺序

**1、** 父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行

**2、** 子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行

**3、** 父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行

**4、** 父类构造方法

**5、** 子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行

**6、** 子类构造方法

**检验一下是不是真懂了：**

```
public class Base {
    private String name = "博客：Soinice";

    public Base() {
        tellName();
        printName();
    }

    public void tellName() {
        System.out.println("Base tell name: " + name);
    }

    public void printName() {
        System.out.println("Base print name: " + name);
    }
}
```

```
public class Dervied extends Base {
    private String name = "Java3y";

    public Dervied() {
        tellName();
        printName();
    }

    @Override
    public void tellName() {
        System.out.println("Dervied tell name: " + name);
    }

    @Override
    public void printName() {
        System.out.println("Dervied print name: " + name);
    }

    public static void main(String[] args) {
        new Dervied();
    }
}
```

**输出数据：**

```
Dervied tell name: null
Dervied print name: null
Dervied tell name: Java3y
Dervied print name: Java3y

Process finished with exit code 0
```

第一次做错的同学点个赞，加个关注不过分吧(hahaha。


### 7、FutureTask是什么

这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。


### 8、sleep() 和 wait() 有什么区别？

两者都可以暂停线程的执行

**1、** 类的不同：

sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。

**2、** 是否释放锁：

sleep() 不释放锁；wait() 释放锁。

**3、** 用途不同：

Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。

**4、** 用法不同：

wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。


### 9、newScheduledThreadPool

**特点**：

创建一个固定长度的线程池，而且支持定时的以及周期性的任务执行，类似于Timer（Timer是Java的一个定时器类）

**缺点**：由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务（比如：一个任务出错，以后的任务都无法继续）。

#
### 10、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？

在 java 虚拟机中，监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。

一旦方法或者代码块被 synchronized 修饰，那么这个部分就放入了监视器的监视区域，确保一次只能有一个线程执行该部分的代码，线程在获取锁之前不允许执行该部分的代码

另外 java 还提供了显式监视器( Lock )和隐式监视器( synchronized )两种锁方案


### 11、用Java实现阻塞队列
### 12、Java线程具有五中基本状态
### 13、方法区/永久代（线程共享）
### 14、Serial 垃圾收集器（单线程、 复制算法）
### 15、如何判断对象是否是垃圾？
### 16、notify() 和 notifyAll() 有什么区别？
### 17、如何找到死锁的线程？
### 18、Java中Semaphore是什么？
### 19、MinorGC，MajorGC、FullGC都什么时候发生？
### 20、JVM 数据运行区，哪些会造成 OOM 的情况？
### 21、为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？
### 22、什么是Executors？
### 23、对象的访问方式有哪些？
### 24、JAVA弱引用
### 25、finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？
### 26、内存溢出和内存泄漏的区别？
### 27、实现可见性的方法有哪些？
### 28、在 Java 程序中怎么保证多线程的运行安全？
### 29、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？
### 30、Java线程数过多会造成什么异常？
### 31、说说 JVM 如何执行 class 中的字节码。




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
