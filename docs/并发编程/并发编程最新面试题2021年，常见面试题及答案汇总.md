# 并发编程最新面试题2021年，常见面试题及答案汇总

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)



### 1、谈谈你知道的垃圾收集器

**Serial 特点：**

**1、** JDK 1.3 开始提供

**2、** 新生代收集器

**3、** 无线程交互开销，单线程收集效率最高

**4、** 进行垃圾收集时需要暂停用户线程

**5、** 适用于客户端，小内存堆的回收

**ParNew 特点：**

**1、** 是 Serial 收集器的多线程并行版

**2、** JDK 7 之前首选的新生代收集器

**3、** 第一款支持并发的收集器，首次实现垃圾收集线程与用户线程基本上同时工作

**4、** 除 Serial 外，只有它能与 CMS 配合

**Parallel Scavenge 特点：**

**1、** 新生代收集器

**2、** 标记-复制算法

**3、** 多线程并行收集器

**4、** 追求高吞吐量，即最小的垃圾收集时间

**5、** 可以配置最大停顿时间、垃圾收集时间占比

**6、** 支持开启垃圾收集自适应调节策略，追求适合的停顿时间或最大的吞吐量

**Serial Old 特点：**

与 Serial 类似，是 Serial 收集器的老年代版本

使用标记-整理算法

**Parallel Old 特点：**

**1、** JDK 6 开始提供

**2、** Parallel Scavenge 的老年代版

**3、** 支持多线程并发收集

**4、** 标记-整理算法

**5、** Parallel Scavenge + Parallel Old 是一个追求高吞吐量的组合

**CMS 特点：**

**1、** 标记-清除算法

**2、** 追求最短回收停顿时间

**3、** 多应用于关注响应时间的 B/S 架构的服务端

**4、** 并发收集、低停顿

**5、** 占用一部分线程资源，应用程序变慢，吞吐量下降

**6、** 无法处理浮动垃圾，可能导致 Full GC

**7、** 内存碎片化问题

**G1 特点：**

**1、** JDK 6 开始实验，JDK 7 商用

**2、** 面向服务端，JDK 9 取代 Parallel Scavenge + Parallel Old

**3、** 结合标记-整理、标记-复制算法

**4、** 首创局部内存回收设计思路

**5、** 基于 Region 内存布局，采用不同策略实现分代

**6、** 不再使用固定大小、固定数量的堆内存分代区域划分

**7、** 优先回收价收益最大的 Region

**8、** 单个或多个 Humongous 区域存放大对象

**9、** 使用记忆集解决跨 Region 引用问题

**10、** 复杂的卡表实现，导致更高的内存占用，堆的 10%～20%

**11、** 全功能垃圾收集器

**12、** 追求有限的时间内最高收集效率、延迟可控的情况下最高吞吐量

**13、** 追求应付内存分配速率，而非一次性清掉所有垃圾内存

**14、** 适用于大内存堆

**Shenandoah 特点：**

**1、** 追求低延迟，停顿 10 毫秒以内

**2、** OpenJDK 12 新特性，RedHat 提供

**3、** 连接矩阵代替记忆集，降低内存使用与伪共享问题出现概率

**ZGC 特点：**

**1、** JDK 11 新加的实验性质的收集器

**2、** 追求低延迟，停顿 10 毫秒以内

**3、** 基于 Region 内存布局

**4、** 未设分代

**5、** 读屏障、染色指针、内存多重映射实现可并发的标记-整理算法

**6、** 染色指针和内存多重映射设计精巧，解决部分性能问题，但降低了可用最大内存、操作系统受限、只支持 32 位、不支持压缩指针等

**7、** 成绩亮眼、性能彪悍


### 2、as-if-serial规则和happens-before规则的区别

**1、** as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。

**2、** as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。

**3、** as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。


### 3、为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？

因为Java所有类的都继承了Object，Java想让任何对象都可以作为锁，并且 wait()，notify()等方法用于等待对象的锁或者唤醒线程，在 Java 的线程中并没有可供任何对象使用的锁，所以任意对象调用方法一定定义在Object类中。

有的人会说，既然是线程放弃对象锁，那也可以把wait()定义在Thread类里面啊，新定义的线程继承于Thread类，也不需要重新定义wait()方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。


### 4、什么是不可变对象，它对写并发应用有什么帮助？

**1、** 不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。

**2、** 不可变对象的类即为不可变类(Immutable Class)。Java平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等。

**3、** 不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。

**1、** 不可变对象永远是线程安全的。

**2、** 只有满足如下状态，一个对象才是不可变的；

**3、** 它的状态不能在创建后再被修改；

**4、** 所有域都是final类型；并且，

**5、** 它被正确创建（创建期间没有发生this引用的逸出）。


### 5、Java 8 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢？

整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会出现java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。


### 6、JVM怎么判断一个对象是不是要回收？

引用计数法（缺点是对于相互引用的对象，无法进行清除） 可达性分析


### 7、如何开启和查看 GC 日志？

**常见的 GC 日志开启参数包括：**

**1、** -Xloggc:filename，指定日志文件路径

**2、** -XX:+PrintGC，打印 GC 基本信息

**3、** -XX:+PrintGCDetails，打印 GC 详细信息

**4、** -XX:+PrintGCTimeStamps，打印 GC 时间戳

**5、** -XX:+PrintGCDateStamps，打印 GC 日期与时间

**6、** -XX:+PrintHeapAtGC，打印 GC 前后的堆、方法区、元空间可用容量变化

**7、** -XX:+PrintTenuringDistribution，打印熬过收集后剩余对象的年龄分布信息，有助于 MaxTenuringThreshold 参数调优设置

**8、** -XX:+PrintAdaptiveSizePolicy，打印收集器自动设置堆空间各分代区域大小、收集目标等自动调节的相关信息

**9、** -XX:+PrintGCApplicationConcurrentTime，打印 GC 过程中用户线程并发时间

**10、** -XX:+PrintGCApplicationStoppedTime，打印 GC 过程中用户线程停顿时间

**11、** -XX:+HeapDumpOnOutOfMemoryError，堆 oom 时自动 dump

**12、** -XX:HeapDumpPath，堆 oom 时 dump 文件路径

Java 9 JVM 日志模块进行了重构，参数格式发生变化，这个需要知道。

GC 日志输出的格式，会随着上面的参数不同而发生变化。关注各个分代的内存使用情况、垃圾回收次数、垃圾回收的原因、垃圾回收占用的时间、吞吐量、用户线程停顿时间。

借助工具可视化工具可以更方便的分析，在线工具 GCeasy；离线版可以使用 GCViewer。

如果现场环境不允许，可以使用 JDK 自带的 jstat 工具监控观察 GC 情况。


### 8、GC 是什么? 为什么要有 GC

GC 是垃圾收集的意思（GabageCollection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。


### 9、程序计数器

保存着当前线程执行的字节码位置,每个线程工作时都有独立的计数器,只为执行Java方法服务,执行Native方法时,程序计数器为空.


### 10、什么叫线程安全？servlet 是线程安全吗?

**1、** 线程安全是编程中的术语，指某个方法在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。

**2、** Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。

**3、** Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一个新的 action 分配给这个请求，请求完成后销毁。

**4、** SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。

**5、** Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多线程的问题。


### 11、多线程的好处
### 12、volatile 变量和 atomic 变量有什么不同？
### 13、并发编程三要素？
### 14、说说类加载的过程
### 15、类加载器双亲委派模型机制？
### 16、复制算法（copying）
### 17、什么是CPU密集
### 18、不可变对象对多线程有什么帮助
### 19、SynchronizedMap和ConcurrentHashMap有什么区别？
### 20、怎么唤醒一个阻塞的线程
### 21、你了解过哪些垃圾收集器？
### 22、CopyOnWriteArrayList 的缺点?
### 23、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？
### 24、说一下 runnable 和 callable 有什么区别
### 25、什么是内存屏障？
### 26、62、volatile 变量和 atomic 变量有什么不同？
### 27、在 Java 程序中怎么保证多线程的运行安全？
### 28、谈谈动态年龄判断
### 29、一个线程运行时发生异常会怎样？
### 30、什么是Vector
### 31、Java 中你怎样唤醒一个阻塞的线程？
### 32、Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
