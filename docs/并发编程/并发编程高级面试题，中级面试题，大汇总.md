# 并发编程高级面试题，中级面试题，大汇总

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://github.com/souyunku/DevBooks/blob/master/docs/index.md)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png)



### 1、Java 如何实现多线程之间的通讯和协作？

可以通过中断 和 共享变量的方式实现线程间的通讯和协作

比如说最经典的生产者-消费者模型：当队列满时，生产者需要等待队列有空间才能继续往里面放入商品，而在等待的期间内，生产者必须释放对临界资源（即队列）的占用权。因为生产者如果不释放对临界资源的占用权，那么消费者就无法消费队列中的商品，就不会让队列有空间，那么生产者就会一直无限等待下去。因此，一般情况下，当队列满时，会让生产者交出对临界资源的占用权，并进入挂起状态。然后等待消费者消费了商品，然后消费者通知生产者队列有空间了。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有商品了。这种互相通信的过程就是线程间的协作。

**Java中线程通信协作的最常见方式：**

**1、** syncrhoized加锁的线程的Object类的wait()/notify()/notifyAll()

**2、** ReentrantLock类加锁的线程的Condition类的await()/signal()/signalAll()

**线程间直接的数据交换：**

通过管道进行线程间通信：字节流、字符流


### 2、Java中用到的线程调度算法是什么？

计算机通常只有一个CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得CPU的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待CPU,JAVA虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配CPU的使用权.

**有两种调度模型**：分时调度模型和抢占式调度模型。

分时调度模型是指让所有的线程轮流获得cpu的使用权,并且平均分配每个线程占用的CPU的时间片这个也比较好理解。

java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。


### 3、在新生代-复制算法

每次垃圾收集都能发现大批对象已死, 只有少量存活、因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集


### 4、说说线程栈

**这里的线程栈应该指的是虚拟机栈吧...**

**1、** JVM规范让每个Java线程拥有自己的独立的JVM栈，也就是Java方法的调用栈。

**2、** 当方法调用的时候，会生成一个栈帧。栈帧是保存在虚拟机栈中的，栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息

**3、** 线程运行过程中，只有一个栈帧是处于活跃状态，称为“当前活跃栈帧”，当前活动栈帧始终是虚拟机栈的栈顶元素。

**4、** 通过jstack工具查看线程状态


### 5、Linux环境下如何查找哪个线程使用CPU最长

**1、** 获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过

**2、** top -H -p pid，顺序不能改变


### 6、动态改变构造

OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理， OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。


### 7、谈谈你知道的垃圾回收算法

**判断对象是否可回收的算法有两种：**

**1、** Reference Counting GC，引用计数算法

**2、** Tracing GC，可达性分析算法

**3、** JVM 各厂商基本都是用的 Tracing GC 实现

**4、** 大部分垃圾收集器遵从了分代收集(Generational Collection)理论。

**5、** 针对新生代与老年代回收垃圾内存的特点，提出了 3 种不同的算法：

**1、** 标记-清除算法(Mark-Sweep)

标记需回收对象，统一回收；或标记存活对象，回收未标记对象。

缺点：

大量对象需要标记与清除时，效率不高

标记、清除产生的大量不连续内存碎片，导致无法分配大对象

**2、** 标记-复制算法(Mark-Copy)

可用内存等分两块，使用其中一块 A，用完将存活的对象复制到另外一块 B，一次性清空 A，然后改分配新对象到 B，如此循环。

缺点：

不适合大量对象不可回收的情况，换句话说就是仅适合大量对象可回收，少量对象需复制的区域

只能使用内存容量的一半，浪费较多内存空间

**3、** 标记-整理算法(Mark-Compact)

标记存活的对象，统一移到内存区域的一边，清空占用内存边界以外的内存。

缺点：

移动大量存活对象并更新引用，需暂停程序运行


### 8、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？

当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。


### 9、Minor GC与Full GC分别在什么时候发生？

新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC


### 10、JIT是什么？

为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化。完成这个任务的编译器，就称为即时编译器（Just In Time Compiler），简称 JIT 编译器。


### 11、as-if-serial规则和happens-before规则的区别
### 12、程序计数器
### 13、你都有哪些手段用来排查内存溢出？
### 14、Java里有哪些引用类型？
### 15、创建线程的四种方式
### 16、介绍一下 JVM 中垃圾收集器有哪些？ 他们特点分别是什么？
### 17、java如何实现多线程之间的通讯和协作？
### 18、synchronized、volatile、CAS 比较
### 19、Java 中 WeakReference 与 SoftReference 的区别？
### 20、为什么 Thread 类的 sleep()和 yield ()方法是静态的？
### 21、Java中Semaphore是什么？
### 22、在 Java 中 Executor 和 Executors 的区别？
### 23、volatile 变量和 atomic 变量有什么不同？
### 24、线程B怎么知道线程A修改了变量
### 25、GC日志的real、user、sys是什么意思？
### 26、如何停止一个正在运行的线程？
### 27、SynchronizedMap 和 ConcurrentHashMap 有什么区别？
### 28、为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？
### 29、标记整理算法(Mark-Compact)
### 30、newFixedThreadPool
### 31、栈




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
