# 并发编程面试题及答案整理，2021年最新，汇总版

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)



### 1、简单描述一下（分代）垃圾回收的过程

分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 `1/3`，老生代的默认占比是 `2/3`。

新生代使用的是复制算法，新生代里有 3 个分区：`Eden`、`To Survivor`、`From Survivor`，它们的默认占比是 `8:1:1`，它的执行流程如下：

**当年轻代中的Eden区分配满的时候，就会触发年轻代的GC（Minor GC）。具体过程如下：**

**1、** 在Eden区执行了 `第一次`GC之后，存活的对象会被移动到其中一个Survivor分区（以下简称from）

**2、** Eden区再次GC，这时会采用复制算法，将Eden和from区一起清理。存活的对象会被复制到to区。接下来，只需要清空from区就可以了


### 2、当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？

如果其他方法没有synchronized的话，其他线程是可以进入的。

所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。


### 3、为什么wait(), notify()和notifyAll ()必须在同步方法或者同步块中被调用？

当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。


### 4、分配CPU和IO密集：

**1、** CPU密集型时，任务可以少配置线程数，大概和机器的cpu核数相当，这样可以使得每个线程都在执行任务

**2、** IO密集型时，大部分线程都阻塞，故需要多配置线程数，2*cpu核数

#
### 5、多线程同步和互斥有几种实现方法，都是什么？

**1、** 线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。

**2、** 线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。

**1、** 线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。

**2、** 用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。


### 6、有哪些打破了双亲委托机制的案例？

**1、** Tomcat可以加载自己目录下的class文件，并不会传递给父类的加载器。

**2、** Java的SPI，发起者是 `BootstrapClassLoader`， `BootstrapClassLoader`已经是最上层的了。它直接获取了 `AppClassLoader`进行驱动加载，和双亲委派是相反的。。


### 7、线程之间如何通信及线程之间如何同步

**1、** 在并发编程中，我们需要处理两个关键问题：线程之间如何通信及线程之间如何同步。通信是指线程之间以如何来交换信息。一般线程之间的通信机制有两种：共享内存和消息传递。

**2、** Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序的Java程序员不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。


### 8、什么是栈

Java 方法执行的内存模型：存储局部变量表，操作数栈，动态链接，方法出口等信息。生命周期与线程相同。


### 9、代码示例

```
package com.lijie;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class TestNewFixedThreadPool {
public static void main(String[] args) {
ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(3);
for (int i = 0; i < 10; i++) {
final int temp = i;
newFixedThreadPool.execute(new Runnable() {
public void run() {
System.out.println(Thread.currentThread().getName() + ",i==" + temp);
}
});
}
}
}
```

#
### 10、多线程同步有哪几种方法？

Synchronized关键字，Lock锁实现，分布式锁等。


### 11、如何在两个线程间共享数据？
### 12、程序计数器有什么作用？
### 13、说说Java 垃圾回收机制
### 14、什么是多线程的上下文切换
### 15、JVM 数据运行区，哪些会造成 OOM 的情况？
### 16、Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？
### 17、谈谈双亲委派模型
### 18、什么是并发队列：
### 19、HashMap中的key，可以是普通对象么？需要什么注意的地方？
### 20、ParNew 垃圾收集器（Serial+多线程）
### 21、在 Java 程序中怎么保证多线程的运行安全？
### 22、什么是本地方法栈
### 23、JAVA虚引用
### 24、栈溢出的原因？
### 25、Java 内存分配
### 26、你做过 JVM 调优，说说如何查看 JVM 参数默认值？
### 27、什么是类加载器，类加载器有哪些？
### 28、什么是逃逸分析？
### 29、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64位？
### 30、为什么你应该在循环中检查等待条件?
### 31、本地方法栈




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "大厂面试题")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png"大厂面试题")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
