# Java常见2021年最新面试题，附答案解析

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://github.com/souyunku/DevBooks/blob/master/docs/index.md)



### 1、为什么代码会重排序？

在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：

在单线程环境下不能改变程序运行的结果；

存在数据依赖关系的不允许重排序

需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。


### 2、什么是多线程中的上下文切换？

**1、** 在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。

**2、** 上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。


### 3、Java 中的final关键字有哪些用法？



(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。


### 4、JSP中的静态包含和动态包含有什么区别？

静态包含是通过JSP的include指令包含页面，动态包含是通过JSP标准动作  包含页面。

静态包含是编译时包含，如果包含的页面不存在则会产生编译错误，而且两个页面的"contentType"属性应保持一致，因为两个页面会合二为一，只产生一个class文件，因此被包含页面发生的变动再包含它的页面更新前不会得到更新。

动态包含是运行时包含，可以向被包含的页面传递参数，包含页面和被包含页面是独立的，会编译出两个class文件，如果被包含的页面不存在，不会产生编译错误，也不影响页面其他部分的执行。


### 5、阐述ArrayList、Vector、LinkedList的存储性能和特性。



ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。

> 补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。



### 6、阐述Spring框架中Bean的生命周期？

**1、** Spring IoC容器找到关于Bean的定义并实例化该Bean。

**2、** pring IoC容器对Bean进行依赖注入。

**3、** 如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法。

**4、** 如果Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法。

**5、** 如果Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法。

**6、** 如果Bean实现了InitializingBean接口，则调用其afterPropertySet方法。

**7、** 如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用。

**8、** 当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用其destroy方法。


### 7、volatile 类型变量提供什么保证？

volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。


### 8、mixin、hoc、render props、react-hooks的优劣如何？
### 9、48、List、Set、Map 和 Queue 之间的区别(答案)
### 10、String str="i"与 String str=new String("i")一样吗？
### 11、怎么获取 Java 程序使用的内存？堆使用的百分比？
### 12、什么是Vector
### 13、JAVA虚引用
### 14、程序计数器为什么是私有的?
### 15、WeakHashMap 是怎么工作的？
### 16、Java对象创建过程
### 17、SWAP会影响性能么？
### 18、Java中的ReadWriteLock是什么？
### 19、Session加载实体对象的过程。
### 20、Java 中如何将字符串转换为整数？
### 21、哪个类包含 clone 方法？是 Cloneable 还是 Object？
### 22、怎么唤醒一个阻塞的线程
### 23、什么是逃逸分析？
### 24、什么是原子类
### 25、什么是Executors？
### 26、什么是B/S架构？什么是C/S架构
### 27、在Java中Executor和Executors的区别？
### 28、你所了解的数据源技术有那些？使用数据源有什么好处？
### 29、说出几条 Java 中方法重载的最佳实践？
### 30、final、finalize()、finally，性质不同
### 31、多线程同步有哪几种方法？
### 32、什么是线程局部变量？
### 33、JDBC操作的步骤
### 34、Query接口的list方法和iterate方法有什么区别？
### 35、Java中Synchronized关键字的使用？
### 36、FutureTask是什么
### 37、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？
### 38、Js如何实现动态效果？
### 39、类加载有几个过程？
### 40、强引用、软引用、弱引用、虚引用是什么，有什么区别？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)




## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
