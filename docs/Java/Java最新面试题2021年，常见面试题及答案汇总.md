# Java最新面试题2021年，常见面试题及答案汇总

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)



### 1、说出 5 个 JDK 1.8 引入的新特性？

**1、** Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：

**2、** Lambda 表达式，允许像对象一样传递匿名函数

**3、** Stream API，充分利用现代多核 CPU，可以写出很简洁的代码

**4、** Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用

**5、** 扩展方法，现在，接口中可以有静态、默认方法。

**6、** 重复注解，现在你可以将相同的注解在同一类型上使用多次。


### 2、用过ConcurrentHashMap，讲一下他和HashTable的不同之处？

ConcurrentHashMap是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。

**看不懂？？？很正常，我也看不懂**

**总结：**

**1、** HashTable就是实现了HashMap加上了synchronized，而ConcurrentHashMap底层采用分段的数组+链表实现，线程安全

**2、** ConcurrentHashMap通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。

**3、** 并且读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。

**4、** Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术

**5、** 扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容


### 3、SynchronizedMap和ConcurrentHashMap有什么区别？

SynchronizedMap一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为map。

**1、** ConcurrentHashMap使用分段锁来保证在多线程下的性能。ConcurrentHashMap中则是一次锁住一个桶。ConcurrentHashMap默认将hash表分为16个桶，诸如get,put,remove等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。

**2、** 另外ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。


### 4、什么是JVM？java虚拟机包括什么？

JVM：java虚拟机，运用硬件或软件手段实现的虚拟的计算机，Java虚拟机包括：寄存器，堆栈，处理器


### 5、如果父类只有有参构造方法，那么子类必须要重写父类的构造方法吗？

必须重写


### 6、嵌套静态类与顶级类有什么区别？

一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。


### 7、Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？

Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。

它的优势有：

**1、** 可以使锁更公平

**2、** 可以使线程在等待锁的时候响应中断

**3、** 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间

**4、** 可以在不同的范围，以不同的顺序获取和释放锁


### 8、Java中Synchronized关键字的使用？

Synchronized关键字在方法签名上，可以防止多个线程同时访问这个对象的synchronized修饰的方法。如果一个对象有多个synchronized方法，只要一个线程访问其中的一个同步方法，那么其他线程就不能访问对象其他的任何一个同步方法。不同对象实例的synchronize方法是互不干扰的，也就是说，其他对象还可以访问这个类中的同步方法。

Synchronized如果修饰的是静态方法，防止多个线程同时访问这个类中的静态同步方法，它对类中所有对象都能起作用。也就是说，只有一个对象一个线程可以访问静态同步方法

Synchronized修饰方法中的某段代码块，只对当前代码块实行互斥访问。当多个线程同步访问同步代码块，同一时间只能有一个线程得到执行，其他线程必须等待当前线程执行完代码块之后才能执行。当一个线程访问同步代码快时，其他线程可以访问非同步的代码。当一个线程访问同步代码块时，那么其他线程访问对其他同步代码块的访问将会被阻塞

Synchronized关键字是不能继承的，如果父类的synchronized在继承时并不自动是synchronized修饰的，需要显示地声明。

Synchronized修饰this时，会得到这个对象的对象锁，当一个线程访问时，那么其他线程访问对象的所有同步代码块或者同步方法，将会被阻塞。


### 9、谈谈对 OOM 的认识

除了程序计数器，其他内存区域都有 OOM 的风险。

**1、** 栈一般经常会发生 StackOverflowError，比如 32 位的 windows 系统单进程限制 2G 内存，无限创建线程就会发生栈的 OOM

**2、** Java 8 常量池移到堆中，溢出会出 java.lang.OutOfMemoryError: Java heap space，设置最大元空间大小参数无效

**3、** 堆内存溢出，报错同上，这种比较好理解，GC 之后无法在堆中申请内存创建对象就会报错

**4、** 方法区 OOM，经常会遇到的是动态生成大量的类、jsp 等

**5、** 直接内存 OOM，涉及到 -XX:MaxDirectMemorySize 参数和 Unsafe 对象对内存的申请


### 10、int和Integer有什么区别？



Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。

**Java 为每个原始类型提供了包装类型：**

**1、** 原始类型: boolean，char，byte，short，int，long，float，double

**2、** 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

```
class AutoUnboxingTest {

    public static void main(String[] args) {
        Integer a = new Integer(3);
        Integer b = 3;                  // 将3自动装箱成Integer类型
        int c = 3;
        System.out.println(a == b);     // false 两个引用没有引用同一对象
        System.out.println(a == c);     // true a自动拆箱成int类型再和c比较
    }
}
```

最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：

```
public class Test03 {

    public static void main(String[] args) {
        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;

        System.out.println(f1 == f2);
        System.out.println(f3 == f4);
    }
}
```

如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，如果看看valueOf的源代码就知道发生了什么。

```
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
```

IntegerCache是Integer的内部类，其代码如下所示：

```
/
     * Cache to support the object identity semantics of autoboxing for values between
     * -128 and 127 (inclusive) as required by JLS.
     *
     * The cache is initialized on first usage、 The size of the cache
     * may be controlled by the {@code -XX:AutoBoxCacheMax=<size>} option.
     * During VM initialization, java.lang.Integer.IntegerCache.high property
     * may be set and saved in the private system properties in the
     * sun.misc.VM class.
     */

    private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer cache[];

        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
            if (integerCacheHighPropValue != null) {
                try {
                    int i = parseInt(integerCacheHighPropValue);
                    i = Math.max(i, 127);
                    // Maximum array size is Integer.MAX_VALUE
                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;

            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k < cache.length; k++)
                cache[k] = new Integer(j++);

            // range [-128, 127] must be interned (JLS7 5.1.7)
            assert IntegerCache.high >= 127;
        }

        private IntegerCache() {}
    }
```

简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1f2的结果是true，而f3f4的结果是false。

> 提醒：越是貌似简单的面试题其中的玄机就越多，需要面试者有相当深厚的功力。



### 11、什么情况发生栈溢出？
### 12、List、Map、Set三个接口存取元素时，各有什么特点？
### 13、react-redux是如何工作的?
### 14、什么是乐观锁和悲观锁
### 15、ParNew 垃圾收集器（Serial+多线程）
### 16、JRE、JDK、JVM 及 JIT 之间有什么不同？
### 17、什么情况会造成元空间溢出？
### 18、什么是线程局部变量？
### 19、JAVA8 与元数据
### 20、谈一谈Hibernate的一级缓存、二级缓存和查询缓存。
### 21、说说G1垃圾收集器的工作原理
### 22、什么是Executors？
### 23、接口和抽象类的区别是什么？
### 24、JDBC操作的步骤
### 25、什么是JDK?什么是JRE？
### 26、synchronized 和 volatile 的区别是什么？
### 27、什么是并发队列：
### 28、HashMap是怎么解决哈希冲突的？
### 29、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？
### 30、阐述ArrayList、Vector、LinkedList的存储性能和特性。
### 31、构造方法能不能重载？能不能重写？
### 32、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
### 33、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？
### 34、我们可以在 hashcode() 中使用随机数字吗？
### 35、synchronized 和 Lock 有什么区别？
### 36、Sql中delete与truncate的区别
### 37、多线程同步有哪几种方法？
### 38、什么是ThreadPoolExecutor？
### 39、Java 中堆和栈有什么区别？
### 40、Servlet中如何获取用户提交的查询参数或表单数据？
### 41、你能保证 GC 执行吗？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "大厂面试题")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png"大厂面试题")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
