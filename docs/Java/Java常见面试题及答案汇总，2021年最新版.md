# Java常见面试题及答案汇总，2021年最新版

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://github.com/souyunku/DevBooks/blob/master/docs/index.md)



### 1、Java 内存分配

寄存器：我们无法控制。

静态域：static定义的静态成员。

常量池：编译时被确定并保存在 .class 文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）。

非 RAM 存储：硬盘等永久存储空间。

堆内存：new 创建的对象和数组，由 Java 虚拟机自动垃圾回收器管理,存取速度慢。

栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性。


### 2、单例优缺点

**优点：**

**1、** 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例

**2、** 单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。

**3、** 提供了对唯一实例的受控访问。

**4、** 由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。

**5、** 允许可变数目的实例。

**6、** 避免对共享资源的多重占用。

**缺点：**

**1、** 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。

**2、** 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。

**3、** 单例类的职责过重，在一定程度上违背了“单一职责原则”。

**4、** 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。


### 3、Servlet的生命周期？

**1、** 加载：判断servlet实例是否存在，如果不存在，就加载serlvet

**2、** 实例化：

**3、** 初始化

4、服务

5、销毁


### 4、JVM的永久代中会发生垃圾回收么

垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区 (注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)


### 5、== 和 equals 的区别是什么？

== 解读

对于基本类型和引用类型 == 的作用效果是不同的，如下所示：

基本类型：比较的是值是否相同； 引用类型：比较的是引用是否相同； 代码示例：

```
String x = "string";
String y = "string";
String z = new String("string");
System.out.println(x==y); // true
System.out.println(x==z); // false
System.out.println(x.equals(y)); // true
System.out.println(x.equals(z)); // true
```

代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。

equals 解读

equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。

首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：

```
class Cat {
    public Cat(String name) {
        this.name = name;
    }
 
    private String name;
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
}
 
Cat c1 = new Cat("提莫");
Cat c2 = new Cat("提莫");
System.out.println(c1.equals(c2)); // false
```

输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：

```
public boolean equals(Object obj) {
    return (this == obj);
}
```

原来 equals 本质上就是 ==。

那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：

```
String s1 = new String("阿莫");
String s2 = new String("阿莫");
System.out.println(s1.equals(s2)); // true
```

同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：

```
public boolean equals(Object anObject) {
    if (this == anObject) {
    return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。

总结：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。


### 6、什么是竞争条件？你怎样发现和解决竞争？

当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。


### 7、ArrayList与LinkedList有什么区别？

**1、** ArrayList与LinkedList都实现了List接口。

**2、** ArrayList是线性表，底层是使用数组实现的，它在尾端插入和访问数据时效率较高，

**3、** Linked是双向链表，他在中间插入或者头部插入时效率较高，在访问数据时效率较低


### 8、谈谈你知道的垃圾收集器

**Serial 特点：**

**1、** JDK 1.3 开始提供

**2、** 新生代收集器

**3、** 无线程交互开销，单线程收集效率最高

**4、** 进行垃圾收集时需要暂停用户线程

**5、** 适用于客户端，小内存堆的回收

**ParNew 特点：**

**1、** 是 Serial 收集器的多线程并行版

**2、** JDK 7 之前首选的新生代收集器

**3、** 第一款支持并发的收集器，首次实现垃圾收集线程与用户线程基本上同时工作

**4、** 除 Serial 外，只有它能与 CMS 配合

**Parallel Scavenge 特点：**

**1、** 新生代收集器

**2、** 标记-复制算法

**3、** 多线程并行收集器

**4、** 追求高吞吐量，即最小的垃圾收集时间

**5、** 可以配置最大停顿时间、垃圾收集时间占比

**6、** 支持开启垃圾收集自适应调节策略，追求适合的停顿时间或最大的吞吐量

**Serial Old 特点：**

与 Serial 类似，是 Serial 收集器的老年代版本

使用标记-整理算法

**Parallel Old 特点：**

**1、** JDK 6 开始提供

**2、** Parallel Scavenge 的老年代版

**3、** 支持多线程并发收集

**4、** 标记-整理算法

**5、** Parallel Scavenge + Parallel Old 是一个追求高吞吐量的组合

**CMS 特点：**

**1、** 标记-清除算法

**2、** 追求最短回收停顿时间

**3、** 多应用于关注响应时间的 B/S 架构的服务端

**4、** 并发收集、低停顿

**5、** 占用一部分线程资源，应用程序变慢，吞吐量下降

**6、** 无法处理浮动垃圾，可能导致 Full GC

**7、** 内存碎片化问题

**G1 特点：**

**1、** JDK 6 开始实验，JDK 7 商用

**2、** 面向服务端，JDK 9 取代 Parallel Scavenge + Parallel Old

**3、** 结合标记-整理、标记-复制算法

**4、** 首创局部内存回收设计思路

**5、** 基于 Region 内存布局，采用不同策略实现分代

**6、** 不再使用固定大小、固定数量的堆内存分代区域划分

**7、** 优先回收价收益最大的 Region

**8、** 单个或多个 Humongous 区域存放大对象

**9、** 使用记忆集解决跨 Region 引用问题

**10、** 复杂的卡表实现，导致更高的内存占用，堆的 10%～20%

**11、** 全功能垃圾收集器

**12、** 追求有限的时间内最高收集效率、延迟可控的情况下最高吞吐量

**13、** 追求应付内存分配速率，而非一次性清掉所有垃圾内存

**14、** 适用于大内存堆

**Shenandoah 特点：**

**1、** 追求低延迟，停顿 10 毫秒以内

**2、** OpenJDK 12 新特性，RedHat 提供

**3、** 连接矩阵代替记忆集，降低内存使用与伪共享问题出现概率

**ZGC 特点：**

**1、** JDK 11 新加的实验性质的收集器

**2、** 追求低延迟，停顿 10 毫秒以内

**3、** 基于 Region 内存布局

**4、** 未设分代

**5、** 读屏障、染色指针、内存多重映射实现可并发的标记-整理算法

**6、** 染色指针和内存多重映射设计精巧，解决部分性能问题，但降低了可用最大内存、操作系统受限、只支持 32 位、不支持压缩指针等

**7、** 成绩亮眼、性能彪悍


### 9、什么是B/S架构？什么是C/S架构

**1、** B/S(Browser/Server)，浏览器/服务器程序

**2、** C/S(Client/Server)，客户端/服务端，桌面应用程序


### 10、String 类的常用方法都有那些？

**1、** indexOf()：返回指定字符的索引。

**2、** charAt()：返回指定索引处的字符。

**3、** replace()：字符串替换。

**4、** trim()：去除字符串两端空白。

**5、** split()：分割字符串，返回一个分割后的字符串数组。

**6、** getBytes()：返回字符串的 byte 类型数组。

**7、** length()：返回字符串长度。

**8、** toLowerCase()：将字符串转成小写字母。

**9、** toUpperCase()：将字符串转成大写字符。

**10、** substring()：截取字符串。

**11、** equals()：字符串比较。


### 11、JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用
### 12、什么是多线程的上下文切换
### 13、Parallel Scavenge 收集器（多线程复制算法、高效）
### 14、Collection 和 Collections 有什么区别？
### 15、并发编程三要素？
### 16、如何开启和查看 GC 日志？
### 17、WeakHashMap 是怎么工作的？
### 18、运行时数据区是什么？
### 19、阐述JDBC操作数据库的步骤。
### 20、Java有没有goto？
### 21、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？
### 22、什么是多线程中的上下文切换？
### 23、线程之间如何通信及线程之间如何同步
### 24、为什么代码会重排序？
### 25、不可变对象对多线程有什么帮助
### 26、JRE、JDK、JVM 及 JIT 之间有什么不同？
### 27、构造器注入和 setter 依赖注入，那种方式更好？
### 28、Java中有几种类型的流？
### 29、判断两个对象是否相同，能使用equlas比较吗？
### 30、新生代与复制算法
### 31、方法区溢出的原因？
### 32、GC 是什么？为什么要有 GC？
### 33、工作中常用的 JVM 配置参数有哪些？
### 34、设计模式分类
### 35、线程之间是如何通信的？
### 36、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
### 37、Java 中，如何计算两个日期之间的差距？
### 38、打印昨天的当前时刻。
### 39、什么是乐观锁和悲观锁
### 40、对象分配内存的方式有哪些？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)




## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
