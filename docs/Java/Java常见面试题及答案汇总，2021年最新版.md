# Java常见面试题及答案汇总，2021年最新版

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)



### 1、String和StringBuilder、StringBuffer的区别？



Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是Java 5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer要高。

**面试题1**

什么情况下用+运算符进行字符串连接比调用StringBuffer/StringBuilder对象的append方法连接字符串性能更好？

**面试题2**

请说出下面程序的输出。

```
class StringEqualTest {

    public static void main(String[] args) {
        String s1 = "Programming";
        String s2 = new String("Programming");
        String s3 = "Program";
        String s4 = "ming";
        String s5 = "Program" + "ming";
        String s6 = s3 + s4;
        System.out.println(s1 == s2);
        System.out.println(s1 == s5);
        System.out.println(s1 == s6);
        System.out.println(s1 == s6.intern());
        System.out.println(s2 == s2.intern());
    }
}
```

**补充：**

解答上面的面试题需要清除两点：1、String对象的intern方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；2、字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象，这一点可以用javap -c StringEqualTest.class命令获得class文件对应的JVM字节码指令就可以看出来。


### 2、请说出与线程同步以及线程调度相关的方法。

**1、** wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；

**2、** sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；

**3、** notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；

**4、** notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；


### 3、你对 Time Slice的理解?

**时间分片**

**1、** React 在渲染（render）的时候，不会阻塞现在的线程

**2、** 如果你的设备足够快，你会感觉渲染是同步的

**3、** 如果你设备非常慢，你会感觉还算是灵敏的

**4、** 虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来

**5、** 同样书写组件的方式

也就是说，这是React背后在做的事情，对于我们开发者来说，是透明的，具体是什么样的效果呢？

![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/4/30/1939/39/97_3.png#alt=97%5C_3.png)![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/4/30/1939/39/97_4.png#alt=97%5C_4.png)有图表三个图表，有一个输入框，以及上面的三种模式

**这个组件非常的巨大，而且在输入框**每次**输入东西的时候，就会进去一直在渲染。**为了更好的看到渲染的性能，Dan为我们做了一个表。

**我们先看看，同步模式：**

![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/4/30/1939/39/97_5.png#alt=97%5C_5.png)![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/4/30/1939/39/97_6.png#alt=97%5C_6.png)

同步模式下，我们都知道，我们没输入一个字符，React就开始渲染，当React渲染一颗巨大的树的时候，是非常卡的，所以才会有shouldUpdate的出现，在这里Dan也展示了，这种卡！

**我们再来看看第二种（Debounced模式）：**

![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/4/30/1939/39/97_7.png#alt=97%5C_7.png)![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/4/30/1939/39/97_8.png#alt=97%5C_8.png)

Debounced模式简单的来说，就是延迟渲染，比如，当你输入完成以后，再开始渲染所有的变化。

这么做的坏处就是，至少不会阻塞用户的输入了，但是依然有非常严重的卡顿。

**切换到异步模式：**

![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/4/30/1939/39/97_9.png#alt=97%5C_9.png)![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/4/30/1939/39/97_10.png#alt=97%5C_10.png)

异步渲染模式就是不阻塞当前线程，继续跑。在视频里可以看到所有的输入，表上都会是原谅色的。

时间分片正是基于可随时打断、重启的Fiber架构,可打断当前任务,优先处理紧急且重要的任务,保证页面的流畅运行.


### 4、CopyOnWriteArrayList 的缺点?

**1、** 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 young gc 或者 full gc。

**2、** 不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。

**3、** 由于实际使用中可能没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。


### 5、Java 中，如何将字符串 YYYYMMDD 转换为日期？

[http://java67.blogspot.sg/2014/12/string-to-date-example-in-java-multithreading.html](http://java67.blogspot.sg/2014/12/string-to-date-example-in-java-multithreading.html)


### 6、CopyOnWriteArrayList 的设计思想?

**1、** 读写分离，读和写分开

**2、** 最终一致性

**3、** 使用另外开辟空间的思路，来解决并发冲突


### 7、HashMap 与 HashTable 有什么区别？

**1、** **线程安全**： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 `synchronized` 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；

**2、** **效率**： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；

**3、** **对Null key 和Null value的支持**： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。

**4、** **初始容量大小和每次扩充容量大小的不同** ：

**1、** 创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。

**2、** 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。

**底层数据结构**：

JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。

**推荐使用：**

在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。


### 8、Parallel Old 收集器（多线程标记整理算法）

Parallel Old 收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在 JDK1.6才开始提供。

在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量， Parallel Old 正是为了在年老代同样提供吞吐量优先的垃圾收集器， 如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代 Parallel Old 收集器的搭配策略。


### 9、ArrayList与LinkedList有什么区别？

**1、** ArrayList与LinkedList都实现了List接口。

**2、** ArrayList是线性表，底层是使用数组实现的，它在尾端插入和访问数据时效率较高，

**3、** Linked是双向链表，他在中间插入或者头部插入时效率较高，在访问数据时效率较低


### 10、解释一下什么叫AOP（面向切面编程）？

AOP（Aspect-Oriented Programming）指一种程序设计范型，该范型以一种称为切面（aspect）的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点（crosscutting concern）。


### 11、Java死锁以及如何避免？
### 12、能够找到 Reference Chain 的对象，就一定会存活么？
### 13、线程的 run()和 start()有什么区别？
### 14、解释servlet如何完成生命周期?
### 15、ArrayList 和 Vector 的区别是什么？
### 16、什么时候用断言（assert）？
### 17、并发关键字 synchronized ？
### 18、如何让正在运行的线程暂停一段时间？
### 19、堆（Heap-线程共享） -运行时数据区
### 20、Java线程具有五中基本状态
### 21、说说 JVM 如何执行 class 中的字节码。
### 22、线程池有什么优点？
### 23、什么是Future？
### 24、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？
### 25、如何阻止表单提交
### 26、重载与重写
### 27、说说CMS垃圾收集器的工作原理
### 28、什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？
### 29、38、数据类型之间的转换：
### 30、List、Set、Map是否继承自Collection接口？
### 31、如何设置请求的编码以及响应内容的类型？
### 32、运行时常量池的作用是什么?
### 33、类加载器
### 34、62、volatile 变量和 atomic 变量有什么不同？
### 35、简述正则表达式及其用途。
### 36、Query接口的list方法和iterate方法有什么区别？
### 37、如何创建一个json对象？
### 38、观察者模式应用场景
### 39、普通类与抽象类有什么区别？
### 40、老年代与标记复制算法




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "大厂面试题")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png"大厂面试题")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
