# Java面试2021秋招面试问题，附答案

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://github.com/souyunku/DevBooks/blob/master/docs/index.md)



### 1、你如何确保main()方法所在的线程是Java 程序最后结束的线程？

我们可以使用Thread类的join()方法来确保所有程序创建的线程在main()方法退出前结束。


### 2、编写多线程程序有几种实现方式？



Java 5以前实现多线程有两种实现方法：一种是继承Thread类；另一种是实现Runnable接口。两种方式都要通过重写run()方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类就无法再继承其他类了，显然使用Runnable接口更为灵活。

> 补充：Java 5以后创建线程还有第三种方式：实现Callable接口，该接口中的call方法可以在线程执行结束时产生一个返回值，代码如下所示：


```
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;


class MyTask implements Callable<Integer> {
    private int upperBounds;

    public MyTask(int upperBounds) {
        this.upperBounds = upperBounds;
    }

    @Override
    public Integer call() throws Exception {
        int sum = 0; 
        for(int i = 1; i <= upperBounds; i++) {
            sum += i;
        }
        return sum;
    }

}

class Test {

    public static void main(String[] args) throws Exception {
        List<Future<Integer>> list = new ArrayList<>();
        ExecutorService service = Executors.newFixedThreadPool(10);
        for(int i = 0; i < 10; i++) {
            list.add(service.submit(new MyTask((int) (Math.random() * 100))));
        }

        int sum = 0;
        for(Future<Integer> future : list) {
            // while(!future.isDone()) ;
            sum += future.get();
        }

        System.out.println(sum);
    }
}
```


### 3、请你谈谈对OOM的认识

OOM是非常严重的问题，除了`程序计数器`，其他内存区域都有溢出的风险。和我们平常工作最密切的，就是堆溢出。另外，元空间在方法区内容非常多的情况下也会溢出。还有就是栈溢出，这个通常影响比较小。堆外也有溢出的可能，这个就比较难排查一些。


### 4、为什么 Java 中的 String 是不可变的（Immutable）？

Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。

**29、** 我们能在 Switch 中使用 String 吗？

从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。

**30、** Java 中的构造器链是什么？

当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。


### 5、请解释将Tomcat作为一个Windows 服务运行会带来哪些好处?

运行Tomcat作为windows服务带来了以下的好处：

**1、** 自动启动:对于需要在维护后远程重新启动系统的环境来说，这是至关重要的

**2、** 启动无活动用户登录的服务器:Tomcat通常在刀片服务器上运行，这些服务器甚至可能没有一个活动监视器，Windows服务可以在没有活动用户的情况下启动

**3、** 安全性:在Windows服务下的Tomcat可以让您在一个特殊的系统帐户下运行它，这个账户可以从其他用户帐户中得到保护


### 6、堆（Heap-线程共享） -运行时数据区

是被线程共享的一块内存区域， 创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。


### 7、介绍一下 JVM 中垃圾收集器有哪些？ 他们特点分别是什么？

**新生代垃圾收集器**

**Serial 收集器**

特点： Serial 收集器只能使用一条线程进行垃圾收集工作，并且在进行垃圾收集的时候，所有的工作线程都需要停止工作，等待垃圾收集线程完成以后，其他线程才可以继续工作。

**使用算法：复制算法**

**ParNew 收集器**

特点： ParNew 垃圾收集器是Serial收集器的多线程版本。为了利用 CPU 多核多线程的优势，ParNew 收集器可以运行多个收集线程来进行垃圾收集工作。这样可以提高垃圾收集过程的效率。

**使用算法：复制算法**

**Parallel Scavenge 收集器**

特点： Parallel Scavenge 收集器是一款多线程的垃圾收集器，但是它又和 ParNew 有很大的不同点。

Parallel Scavenge 收集器和其他收集器的关注点不同。其他收集器，比如 ParNew 和 CMS 这些收集器，它们主要关注的是如何缩短垃圾收集的时间。而 Parallel Scavenge 收集器关注的是如何控制系统运行的吞吐量。这里说的吞吐量，指的是 CPU 用于运行应用程序的时间和 CPU 总时间的占比，吞吐量 = 代码运行时间 / （代码运行时间 + 垃圾收集时间）。如果虚拟机运行的总的 CPU 时间是 100 分钟，而用于执行垃圾收集的时间为 1 分钟，那么吞吐量就是 99%。

**使用算法：复制算法**

**老年代垃圾收集器**

**Serial Old 收集器**

特点： Serial Old 收集器是 Serial 收集器的老年代版本。这款收集器主要用于客户端应用程序中作为老年代的垃圾收集器，也可以作为服务端应用程序的垃圾收集器。

**使用算法：标记-整理**

**Parallel Old 收集器**

特点： Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本这个收集器是在 JDK1.6 版本中出现的，所以在 JDK1.6 之前，新生代的 Parallel Scavenge 只能和 Serial Old 这款单线程的老年代收集器配合使用。Parallel Old 垃圾收集器和 Parallel Scavenge 收集器一样，也是一款关注吞吐量的垃圾收集器，和 Parallel Scavenge 收集器一起配合，可以实现对 Java 堆内存的吞吐量优先的垃圾收集策略。

**使用算法：标记-整理**

**CMS 收集器**

特点： CMS 收集器是目前老年代收集器中比较优秀的垃圾收集器。CMS 是 Concurrent Mark Sweep，从名字可以看出，这是一款使用"标记-清除"算法的并发收集器。

CMS 垃圾收集器是一款以获取最短停顿时间为目标的收集器。如下图所示：

![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/05/34/39_3.png#alt=39%5C_3.png)

**从图中可以看出，CMS 收集器的工作过程可以分为 4 个阶段：**

**1、** 初始标记（CMS initial mark）阶段

**2、** 并发标记（CMS concurrent mark）阶段

**3、** 重新标记（CMS remark）阶段

**4、** 并发清除(（CMS concurrent sweep）阶段

使用算法：复制+标记清除

**其他**

**G1 垃圾收集器**

特点： 主要步骤：`初始标记，并发标记，重新标记，复制清除。`

**使用算法：复制 + 标记整理**


### 8、为什么使用Executor框架比使用应用创建和管理线程好？

为什么要使用Executor线程池框架

**1、** 每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。

**2、** 调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。

**3、** 直接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。

**使用Executor线程池框架的优点 **

**1、** 能复用已存在并空闲的线程从而减少线程对象的创建从而减少了消亡线程的开销。

**2、** 可有效控制最大并发线程数，提高系统资源使用率，同时避免过多资源竞争。

**3、** 框架中已经有定时、定期、单线程、并发数控制等功能。

综上所述使用线程池框架Executor能更好的管理线程、提供系统资源使用率。


### 9、Linux环境下如何查找哪个线程使用CPU最长

**1、** 获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过

**2、** top -H -p pid，顺序不能改变


### 10、为什么使用Executor框架？

**1、** 每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。

**2、** 调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。

**3、** 接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。


### 11、适配器模式和装饰器模式有什么区别？
### 12、日期和时间：
### 13、如果使用Object作为HashMap的Key，应该怎么办呢？
### 14、Java的双亲委托机制是什么？
### 15、ArrayList 和 Vector 的区别是什么？
### 16、volatile 类型变量提供什么保证？
### 17、什么是线程池？有哪几种创建方式？
### 18、TCP编程与UDP编程有什么区别？
### 19、说说线程栈
### 20、如何在jsp页面上显示一些特定格式的数字或者日期
### 21、重排序遵守的规则
### 22、Spring MVC的工作原理是怎样的？
### 23、说说 JVM 如何执行 class 中的字节码。
### 24、普通类与抽象类有什么区别？
### 25、内存溢出和内存泄漏的区别？
### 26、64 位 JVM 中，int 的长度是多数？
### 27、什么是线程池？
### 28、volatile有什么用？能否用一句话说明下volatile的应用场景？
### 29、HashMap 的长度为什么是2的幂次方
### 30、如何实现数组和 List 之间的转换？
### 31、用Java的套接字编程实现一个多线程的回显（echo）服务器。
### 32、ThreadPoolExecutor饱和策略有哪些？
### 33、synchronized关键字的用法？
### 34、模块化编程与热插拔
### 35、Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？
### 36、Files的常用方法都有哪些？
### 37、ZGC 了解吗？
### 38、JDBC操作的步骤
### 39、redux异步中间件之间的优劣?
### 40、原子类的常用类




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)




## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
