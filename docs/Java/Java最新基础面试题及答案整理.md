# Java最新基础面试题及答案整理

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)



### 1、Tcp协议的特点

**1、** TCP 是面向连接的传输层协议

**2、** 每一条 TCP 连接只能有两个端点(endpoint),每一条 TCP 连接只能是点对点的（一对一）

**3、** TCP 提供可靠交付的服务

**4、** TCP 提供全双工通信

**5、** 面向字节流

**1、** TCP 是面向连接的传输层协议

**2、** 每一条 TCP 连接只能有两个端点(endpoint),每一条 TCP 连接只能是点对点的（一对一）

**3、** TCP 提供可靠交付的服务

**4、** TCP 提供全双工通信

**5、** 面向字节流


### 2、a = a + b 与 a += b 的区别

+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是 a += b 没问题，如下：

```java
byte a = 127;
        byte b = 127;
        b = a + b; // error : cannot convert from int to byte
        b += a; // ok
```

（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）


### 3、如何部署一个web项目？

**1、** 可以将web项目打包成.war文件

**2、** 把war文件放在webapps文件夹中


### 4、设计模式的六大原则

![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/047/42/89_2.png#alt=89%5C_2.png)

- 开放封闭原则（Open Close Principle）

**原则思想：**

尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化

**描述：**

一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。

**优点：**

单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。

- 里氏代换原则（Liskov Substitution Principle）

**原则思想：**

使用的基类可以在任何地方使用继承的子类，完美的替换基类。

**大概意思是：**

子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。

**优点：**

增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。

- 依赖倒转原则（Dependence Inversion Principle）

**1、** 依赖倒置原则的核心思想是面向接口编程.

**2、** 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，

**3、** 这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。

- 接口隔离原则（Interface Segregation Principle）

**这个原则的意思是：**

使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

**例如：**

支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口

- 迪米特法则（最少知道原则）（Demeter Principle）

**原则思想：**

一个对象应当对其他对象有尽可能少地了解，简称类间解耦

大概意思就是一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。

**优点：**

低耦合，高内聚。

- 单一职责原则（Principle of single responsibility）

**原则思想：**

一个方法只负责一件事情。

**描述：**

单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。

**优点：**

降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。


### 5、ArrayList和Vector有什么不同之处？

**Vector方法带上了synchronized关键字，是线程同步的**

**1、** ArrayList添加方法源码 ![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/045/42/87_10.png#alt=87%5C_10.png)

**2、** Vector添加源码（加锁了synchronized关键字） ![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/045/42/87_11.png#alt=87%5C_11.png)


### 6、接口是什么？为什么要使用接口而不是直接使用具体类？

接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。


### 7、集合和数组的区别

**1、** 数组是固定长度的；集合可变长度的。

**2、** 数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。

**3、** 数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。


### 8、FutureTask是什么

这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。


### 9、JVM 监控与分析工具你用过哪些？介绍一下。

**1、** jps，显示系统所有虚拟机进程信息的命令行工具

**2、** jstat，监视分析虚拟机运行状态的命令行工具

**3、** jinfo，查看和调整虚拟机参数的命令行工具

**4、** jmap，生成虚拟机堆内存转储快照的命令行工具

**5、** jhat，显示和分析虚拟机的转储快照文件的命令行工具

**6、** jstack，生成虚拟机的线程快照的命令行工具

**7、** jcmd，虚拟机诊断工具，JDK 7 提供

**8、** jhsdb，基于服务性代理实现的进程外可视化调试工具，JDK 9 提供

**9、** JConsole，基于JMX的可视化监视和管理工具

**10、** jvisualvm，图形化虚拟机使用情况的分析工具

**11、** Java Mission Control，监控和管理 Java 应用程序的工具

**1、** MAT，Memory Analyzer Tool，虚拟机内存分析工具

**2、** vjtools，唯品会的包含核心类库与问题分析工具

**3、** arthas，阿里开源的 Java 诊断工具

**4、** greys，JVM进程执行过程中的异常诊断工具

**5、** GCHisto，GC 分析工具

**6、** GCViewer，GC 日志文件分析工具

**7、** GCeasy，在线版 GC 日志文件分析工具

**8、** JProfiler，检查、监控、追踪 Java 性能的工具

**9、** BTrace，基于动态字节码修改技术(Hotswap)实现的Java程序追踪与分析工具

**下面可以重点体验下：**

JDK 自带的命令行工具方便快捷，不是特别复杂的问题可以快速定位；

阿里的 arthas 命令行也不错；

可视化工具 MAT、JProfiler 比较强大。


### 10、Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）

JVM 的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在 JVM 启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。

堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些 对象回收掉之前，他们会一直占据堆内存空间。


### 11、请解释Tomcat中使用的连接器是什么?
### 12、谈谈JVM中，对类加载器的认识
### 13、同步方法和同步块，哪个是更好的选择？
### 14、Java 内存分配
### 15、JVM的永久代中会发生垃圾回收么
### 16、TCP编程与UDP编程有什么区别？
### 17、Java 8 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢？
### 18、mixin、hoc、render props、react-hooks的优劣如何？
### 19、Set接口有什么特点
### 20、线程的生命周期？
### 21、不可变对象对多线程有什么帮助
### 22、Java都有那些开发平台？
### 23、什么是接口？
### 24、sleep方法和wait方法有什么区别?
### 25、CopyOnWriteArrayList 是什么?
### 26、如何检查出两个给定的字符串是反序的？
### 27、哪些是 GC Roots？
### 28、创建线程的有哪些方式？
### 29、计算机网络有几层？
### 30、说一下垃圾分代收集的过程
### 31、说出几点 Java 中使用 Collections 的最佳实践
### 32、创建线程的三种方式的对比？
### 33、什么是同步任务？什么是异步任务？
### 34、会话跟踪技术有那些？
### 35、请解释什么是Tomcat Coyote ?
### 36、解释如何使用WAR文件部署web应用程序?
### 37、84.Map有什么特点
### 38、React最新的生命周期是怎样的?
### 39、死锁与活锁的区别，死锁与饥饿的区别？
### 40、环境变量Path和ClassPath的作用是什么？如何设置这两个环境变量？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "大厂面试题")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png"大厂面试题")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
