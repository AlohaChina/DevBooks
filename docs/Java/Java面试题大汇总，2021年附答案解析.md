# Java面试题大汇总，2021年附答案解析

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)



### 1、在没有使用临时变量的情况如何交换两个整数变量的值？

解决方案

[https://blog.csdn.net/zidane_2014/article/details/34180223](https://blog.csdn.net/zidane_2014/article/details/34180223)


### 2、List 和 Set 的区别

List , Set 都是继承自Collection 接口

**1、** List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。

**2、** Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。

**3、** 另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。

Set和List对比

**1、** Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。

**2、** List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变


### 3、redux与mobx的区别?

**两者对比:**

**1、** redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中

**2、** redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存数据，数据变化后自动处理响应的操作

**3、** redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改

**4、** mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用

**5、** mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易

**场景辨析:**

基于以上区别,我们可以简单得分析一下两者的不同使用场景.

mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力不从心.

redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操作，由于redux不可变的特性，天然支持这些操作.

mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.

当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用mobx作为组件局部状态管理器来用.


### 4、形参与实参

形参：全称为“形式参数”，是在定义方法名和方法体的时候使用的参数，用于接收调用该方法时传入的实际值；实参：全称为“实际参数”，是在调用方法时传递给该方法的实际值。


### 5、阐述ArrayList、Vector、LinkedList的存储性能和特性。



ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。

> 补充：遗留容器中的Properties类和Stack类在设计上有严重的问题，Properties是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关联一个Hashtable并将其两个泛型参数设置为String类型，但是Java API中的Properties直接继承了Hashtable，这很明显是对继承的滥用。这里复用代码的方式应该是Has-A关系而不是Is-A关系，另一方面容器都属于工具类，继承工具类本身就是一个错误的做法，使用工具类最好的方式是Has-A关系（关联）或Use-A关系（依赖）。同理，Stack类继承Vector也是不正确的。Sun公司的工程师们也会犯这种低级错误，让人唏嘘不已。



### 6、Java中的包装类都是那些？

**1、** byte：Byte

**2、** short：Short

**3、** int：Integer

**4、** long：Long

**5、** float：Float

**6、** double：Double

**7、** char：Character

**8、** boolean：Boolean


### 7、守护线程和用户线程有什么区别呢？

**用户 (User) 线程：**

运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程

**守护 (Daemon) 线程：**

运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作


### 8、我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？

是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 128。


### 9、观察者模式应用场景

**1、** 关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。事件多级触发场景。

**2、** 跨系统的消息交换场景，如消息队列、事件总线的处理机制。

- 代码演示

**1、** 定义抽象观察者，每一个实现该接口的实现类都是具体观察者。

```
package com.lijie;

//观察者的接口，用来存放观察者共有方法
public interface Observer {
    // 观察者方法
    void update(int state);
}
```

**2、** 定义具体观察者

```
package com.lijie;

// 具体观察者
public class ObserverImpl implements Observer {

    // 具体观察者的属性
    private int myState;

    public void update(int state) {
        myState=state;
        System.out.println("收到消息,myState值改为："+state);
    }

    public int getMyState() {
        return myState;
    }
}
```

**3、** 定义主题。主题定义观察者数组，并实现增、删及通知操作。

```
package com.lijie;

import java.util.Vector;

//定义主题，以及定义观察者数组，并实现增、删及通知操作。
public class Subjecct {
    //观察者的存储集合，不推荐ArrayList，线程不安全，
    private Vector<Observer> list = new Vector<>();

    // 注册观察者方法
    public void registerObserver(Observer obs) {
        list.add(obs);
    }
    // 删除观察者方法
    public void removeObserver(Observer obs) {
        list.remove(obs);
    }

    // 通知所有的观察者更新
    public void notifyAllObserver(int state) {
        for (Observer observer : list) {
            observer.update(state);
        }
    }
}
```

**4、** 定义具体的，他继承继承Subject类，在这里实现具体业务，在具体项目中，该类会有很多。

```
package com.lijie;

//具体主题
public class RealObserver extends Subjecct {
    //被观察对象的属性
     private int state;
     public int getState(){
         return state;
     }
     public void  setState(int state){
         this.state=state;
         //主题对象(目标对象)值发生改变
         this.notifyAllObserver(state);
     }
}
```

**5、** 运行测试

```
package com.lijie;

public class Client {

    public static void main(String[] args) {
        // 目标对象
        RealObserver subject = new RealObserver();
        // 创建多个观察者
        ObserverImpl obs1 = new ObserverImpl();
        ObserverImpl obs2 = new ObserverImpl();
        ObserverImpl obs3 = new ObserverImpl();
        // 注册到观察队列中
        subject.registerObserver(obs1);
        subject.registerObserver(obs2);
        subject.registerObserver(obs3);
        // 改变State状态
        subject.setState(300);
        System.out.println("obs1观察者的MyState状态值为："+obs1.getMyState());
        System.out.println("obs2观察者的MyState状态值为："+obs2.getMyState());
        System.out.println("obs3观察者的MyState状态值为："+obs3.getMyState());
        // 改变State状态
        subject.setState(400);
        System.out.println("obs1观察者的MyState状态值为："+obs1.getMyState());
        System.out.println("obs2观察者的MyState状态值为："+obs2.getMyState());
        System.out.println("obs3观察者的MyState状态值为："+obs3.getMyState());
    }
}
```


### 10、什么是策略模式

定义了一系列的算法 或 逻辑 或 相同意义的操作，并将每一个算法、逻辑、操作封装起来，而且使它们还可以相互替换。（其实策略模式Java中用的非常非常广泛）

我觉得主要是为了 简化 if...else 所带来的复杂和难以维护。


### 11、介绍一下类文件结构吧！
### 12、CAS 的会产生什么问题？
### 13、Java 中会存在内存泄漏?简述一下
### 14、String和StringBuilder、StringBuffer的区别？
### 15、详细介绍一下JVM内存模型
### 16、内存溢出和内存泄漏的区别？
### 17、字符串常量存放在哪个区域？
### 18、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?
### 19、抽象类（abstract class）和接口（interface）有什么异同？
### 20、那些地方用到了单例模式
### 21、CyclicBarrier和CountDownLatch的区别
### 22、Java内存模型
### 23、启动一个线程是调用run()还是start()方法？
### 24、ArrayList 和 Vector 的区别是什么？
### 25、setState到底是异步还是同步?
### 26、CopyOnWriteArrayList 的使用场景?
### 27、类初始化的情况有哪些？
### 28、用Java写一个折半查找。
### 29、Java会存在内存泄漏吗？请简单描述。
### 30、死锁与活锁的区别，死锁与饥饿的区别？
### 31、HashMap的扩容操作是怎么实现的？
### 32、模式的职责
### 33、说一下 JVM 调优的工具？
### 34、equals 和 == 的区别？#
### 35、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？
### 36、java 面向对象编程三大特性------封装、继承、多态
### 37、Java 中 WeakReference 与 SoftReference的区别？
### 38、什么是过滤器？怎么创建一个过滤器
### 39、单例模式的线程安全性
### 40、什么是ThreadPoolExecutor？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
