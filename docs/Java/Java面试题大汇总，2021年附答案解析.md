# Java面试题大汇总，2021年附答案解析

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)



### 1、CyclicBarrier和CountDownLatch的区别

**1、** CountDownLatch简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用countDown()方法发出通知后，当前线程才可以继续执行。

**2、** cyclicBarrier是所有线程都进行等待，直到所有线程都准备好进入await()方法之后，所有线程同时开始执行！

**3、** CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。

**4、** CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。如果被中断返回true，否则返回false。


### 2、Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？

**1、** Dump文件是进程的内存镜像。可以把程序的执行状态通过调试器保存到dump文件中。

**2、** 在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java应用的 dump 文件。

**3、** 在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。


### 3、48、List、Set、Map 和 Queue 之间的区别(答案)

List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。


### 4、TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？



TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。

例子1：

```

public class Student implements Comparable<Student> {
    private String name;        // 姓名
    private int age;            // 年龄

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student [name=" + name + ", age=" + age + "]";
    }

    @Override
    public int compareTo(Student o) {
        return this.age - o.age; // 比较年龄(年龄的升序)
    }

}
```

```
import java.util.Set;
import java.util.TreeSet;

class Test01 {

    public static void main(String[] args) {
        Set<Student> set = new TreeSet<>();     // Java 7的钻石语法(构造器后面的尖括号中不需要写类型)
        set.add(new Student("Hao LUO", 33));
        set.add(new Student("XJ WANG", 32));
        set.add(new Student("Bruce LEE", 60));
        set.add(new Student("Bob YANG", 22));

        for(Student stu : set) {
            System.out.println(stu);
        }
//      输出结果: 
//      Student [name=Bob YANG, age=22]
//      Student [name=XJ WANG, age=32]
//      Student [name=Hao LUO, age=33]
//      Student [name=Bruce LEE, age=60]
    }
}
```

例子2：

```
public class Student {
    private String name;    // 姓名
    private int age;        // 年龄

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    /
     * 获取学生姓名
     */
    public String getName() {
        return name;
    }

    /
     * 获取学生年龄
     */
    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "Student [name=" + name + ", age=" + age + "]";
    }

}
```

```
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

class Test02 {

    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();     // Java 7的钻石语法(构造器后面的尖括号中不需要写类型)
        list.add(new Student("Hao LUO", 33));
        list.add(new Student("XJ WANG", 32));
        list.add(new Student("Bruce LEE", 60));
        list.add(new Student("Bob YANG", 22));

        // 通过sort方法的第二个参数传入一个Comparator接口对象
        // 相当于是传入一个比较对象大小的算法到sort方法中
        // 由于Java中没有函数指针、仿函数、委托这样的概念
        // 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调
        Collections.sort(list, new Comparator<Student> () {

            @Override
            public int compare(Student o1, Student o2) {
                return o1.getName().compareTo(o2.getName());    // 比较学生姓名
            }
        });

        for(Student stu : list) {
            System.out.println(stu);
        }
//      输出结果: 
//      Student [name=Bob YANG, age=22]
//      Student [name=Bruce LEE, age=60]
//      Student [name=Hao LUO, age=33]
//      Student [name=XJ WANG, age=32]
    }
}
```


### 5、Jsp包含那些隐藏对象或者内建对象

**1、** Page

**2、** pageContext

**3、** request

**4、** response

**5、** out

**6、** session

**7、** application

**8、** config

**9、** exception


### 6、Java 中 java.util.Date 与 java.sql.Date 有什么区别？

[http://java67.blogspot.sg/2014/02/how-to-convert-javautildate-to-javasqldate-example.html](http://java67.blogspot.sg/2014/02/how-to-convert-javautildate-to-javasqldate-example.html)


### 7、代理的分类

**1、** 静态代理(静态定义代理类)

**2、** 动态代理(动态生成代理类，也称为Jdk自带动态代理)

**3、** Cglib 、javaassist（字节码操作库）


### 8、Java 中，怎么获取一个文件中单词出现的最高频率？

解决方案

[http://java67.blogspot.com/2015/10/java-program-to-find-repeated-words-and-count.html](http://java67.blogspot.com/2015/10/java-program-to-find-repeated-words-and-count.html)


### 9、启动一个线程是调用run()还是start()方法？



启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。


### 10、运行时异常与受检异常有何异同？



异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在_Effective Java_中对异常的使用给出了以下指导原则：

**1、** 不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）

**2、** 对可以恢复的情况使用受检异常，对编程错误使用运行时异常

**3、** 避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）

**4、** 优先使用标准的异常

**5、** 每个方法抛出的异常都要有文档

**6、** 保持异常的原子性

**7、** 不要在catch中忽略掉捕获到的异常


### 11、详细介绍一下JVM内存模型
### 12、打印昨天的当前时刻。
### 13、在新生代-复制算法
### 14、正则表达式有那些符号？
### 15、串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
### 16、抽象的关键字是什么？
### 17、什么是指令重排序？
### 18、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？
### 19、什么是DAO模式？
### 20、Java的双亲委托机制是什么？
### 21、Java 中，throw 和 throws 有什么区别
### 22、简述一下面向对象的”六原则一法则”。
### 23、分代收集算法
### 24、什么是父类引用指向子类对象？
### 25、32 位和 64 位的 JVM，int 类型变量的长度是多数？
### 26、Java反射创建对象效率高还是通过new创建对象的效率高？
### 27、请说明NAT协议的目的是什么?
### 28、setState到底是异步还是同步?
### 29、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？
### 30、线程之间如何通信及线程之间如何同步
### 31、重载和重写的区别
### 32、TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？
### 33、不可变对象对多线程有什么帮助
### 34、死锁与活锁的区别，死锁与饥饿的区别？
### 35、在Java中CycliBarriar和CountdownLatch有什么区别？
### 36、HashSet与HashMap的区别
### 37、final、finalize 和 finally 的不同之处？
### 38、适配器模式和代理模式之前有什么不同？
### 39、普通类与抽象类有什么区别？
### 40、写一段代码在遍历 ArrayList 时移除一个元素？




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)


## 其他，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "大厂面试题")](https://souyunku.lanzous.com/b0alp9b9g "大厂面试题")

## 关注公众号：架构师专栏，回复：“面试题”，即可

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/jiagoushi.png "架构师专栏")](https://souyunku.lanzous.com/b0alp9b9g "架构师专栏")

## 关注公众号：架构师专栏，回复：“面试题”，即可
