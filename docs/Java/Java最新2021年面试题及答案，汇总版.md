# Java最新2021年面试题及答案，汇总版

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://github.com/souyunku/DevBooks/blob/master/docs/index.md)



### 1、如何设置请求的编码以及响应内容的类型？

通过请求对象（ServletRequest）的setCharacterEncoding(String)方法可以设置请求的编码，其实要彻底解决乱码问题就应该让页面、服务器、请求和响应、Java程序都使用统一的编码，最好的选择当然是UTF-8；通过响应对象（ServletResponse）的setContentType(String)方法可以设置响应内容的类型，当然也可以通过HttpServletResponsed对象的setHeader(String, String)方法来设置。


### 2、JVM垃圾回收时候如何确定垃圾？什么是GC Roots？

JVM采用的是可达性分析算法。JVM是通过GC Roots来判定对象的存活的。从`GC Roots`向下追溯、搜索，会产生一个叫做`Reference Chain`的链条。当一个对象不能和任何一个GC Root产生关系，就判定为垃圾。

**GC Roots大体包括：**

**1、** 活动线程相关的各种引用，比如虚拟机栈中栈帧里的引用。

**2、** 类的静态变量的引用。

**3、** JNI引用等。

**当然也有比较详细的回答，个人认为这些就够了。详细版本如下：**

**1、** Java线程中，当前所有正在被调用的方法的 `引用类型`参数、局部变量、临时值等。也就是与我们 `栈帧`相关的各种引用。

**2、** 所有当前被加载的Java类。

**3、** Java类的引用类型静态变量。

**4、** 运行时常量池里的引用类型常量（String或Class类型）。

**5、** JVM内部数据结构的一些引用，比如 `sun.jvm.hotspot.memory.Universe`类。

**6、** 用于同步的监控对象，比如调用了对象的 `wait()`方法。

**7、** JNI handles，包括global handles和local handles


### 3、如果你提交任务时，线程池队列已满，这时会发生什么

**有俩种可能：**

**1、** 如果使用的是无界队列 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务

**2、** 如果使用的是有界队列比如 ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue 中，ArrayBlockingQueue 满了，会根据maximumPoolSize 的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue 继续满，那么则会使用拒绝策略RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy


### 4、String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的？

**可变性**

String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[]value，这两种对象都是可变的。

**线程安全性**

String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。

**性能**

每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 **对于三者使用的总结：** 如果要操作少量的数据用 = String 单线程操作字符串缓冲区 下操作大量数据 = StringBuilder 多线程操作字符串缓冲区 下操作大量数据 = StringBuffer


### 5、HashMap是怎么解决哈希冲突的？

在解决这个问题之前，我们首先需要知道**什么是哈希冲突**，而在了解哈希冲突之前我们还要知道**什么是哈希**才行；

**什么是哈希？**

Hash，一般翻译为“散列”，也有直接音译为“哈希”的， Hash就是指使用哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。

**什么是哈希冲突？**

当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）

**HashMap的数据结构**

在Java中，保存数据有两种比较简单的数据结构：数组和链表

**1、** 数组的特点是：寻址容易，插入和删除困难；

**2、** 链表的特点是：寻址困难，但插入和删除容易；

**3、** 所以我们将数组和链表结合在一起，发挥两者各自的优势，就可以使用俩种方式：链地址法和开放地址法可以解决哈希冲突：

![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/056/58/114_9.png#alt=114%5C_9.png)

**1、** 链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；

**2、** 开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。

但相比于hashCode返回的int类型，我们HashMap初始的容量大小`DEFAULT_INITIAL_CAPACITY = 1 << 4`（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化

**hash()函数**

上面提到的问题，主要是因为如果使用hashCode取余，那么相当于**参与运算的只有hashCode的低位**，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为**扰动**，在**JDK 1.8**中的hash()函数如下：

```
static final int hash(Object key) {
int h;
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);// 与自己右移16位进行异或运算（高低位异或）
}
```

这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）

**简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：**

**1、** 链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；

**2、** 开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。


### 6、CopyOnWriteArrayList 是什么?

CopyOnWriteArrayList 是一个并发容器。有很多人称它是线程安全的，我认为这句话不严谨，缺少一个前提条件，那就是非复合场景下操作它是线程安全的。

CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出 ConcurrentModificationException。在CopyOnWriteArrayList 中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。


### 7、线程的调度策略

**线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行：**

**1、** 线程体中调用了yield方法让出了对cpu的占用权利

**2、** 线程体中调用了sleep方法使线程进入睡眠状态

**3、** 线程由于IO操作受到阻塞

**4、** 另外一个更高优先级线程出现

5）在支持时间片的系统中，该线程的时间片用完


### 8、“a==b”和”a.equals(b)”有什么区别？

如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。


### 9、JVM 的内存模型以及分区情况和作用

**如下图所示：**

![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/5/2/05/34/39_2.png#alt=39%5C_2.png)

黄色部分为线程共有，蓝色部分为线程私有。

- 方法区

用于存储虚拟机加载的类信息，常量，静态变量等数据。

- 堆

存放对象实例，所有的对象和数组都要在堆上分配。 是 JVM 所管理的内存中最大的一块区域。

- 栈

Java 方法执行的内存模型：存储局部变量表，操作数栈，动态链接，方法出口等信息。生命周期与线程相同。

- 本地方法栈

作用与虚拟机栈类似，不同点本地方法栈为 native 方法执行服务，虚拟机栈为虚拟机执行的 Java 方法服务。

- 程序计数器

当前线程所执行的行号指示器。是 JVM 内存区域最小的一块区域。执行字节码工作时就是利用程序计数器来选取下一条需要执行的字节码指令。


### 10、redux的工作流程?

**首先，我们看下几个核心概念：**

**1、** Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。

**2、** State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这种时点的数据集合，就叫做State。

**3、** Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应该要发生变化了。

**4、** Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，所以我们定义一个函数来生成Action，这个函数就叫Action Creator。

**5、** Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参数，返回一个新的State。

**6、** dispatch：是View发出Action的唯一方法。

**然后我们过下整个工作流程：**

**1、** 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。

**2、** 然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State

**3、** State一旦有变化，Store就会调用监听函数，来更新View。

到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式保证了流程的清晰。

![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2020/4/30/1939/39/97_11.png#alt=97%5C_11.png)

> [redux原理详解](https://github.com/xiaomuzhu/front-end-interview/blob/master/docs/guide/redux.md)



### 11、MyBatis中使用#和$书写占位符有什么区别？
### 12、说说Java 垃圾回收机制
### 13、84.Map有什么特点
### 14、ReadWriteLock是什么
### 15、栈
### 16、谈谈对 OOM 的认识
### 17、Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？
### 18、集合框架底层数据结构
### 19、抽象的关键字是什么？
### 20、请解释什么是Tomcat Coyote ?
### 21、什么是双亲委派机制？
### 22、JVM 监控与分析工具你用过哪些？介绍一下。
### 23、JIT 是什么？
### 24、如何决定使用 HashMap 还是 TreeMap？
### 25、类加载器
### 26、描述一下JVM加载class文件的原理机制？
### 27、Java语言有哪些特点？
### 28、说一下堆和栈的区别
### 29、redux中如何进行异步操作?
### 30、什么是Java Timer 类？如何创建一个有特定时间间隔的任务？
### 31、Try.catch.finally是必须要存在的吗？
### 32、Java 中，直接缓冲区与非直接缓冲器有什么区别？
### 33、单例模式使用注意事项：
### 34、依赖注入和工程模式之间有什么不同？
### 35、Java 中的final关键字有哪些用法？
### 36、如何进行单元测试
### 37、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？
### 38、Java 中，怎么在格式化的日期中显示时区？
### 39、&和&&的区别？
### 40、Java语言如何进行异常处理，关键字：throws、throw、try、catch、finally分别如何使用？
### 41、在Java中定义一个不做事且没有参数的构造方法的作用




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)




## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
