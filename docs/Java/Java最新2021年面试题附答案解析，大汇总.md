# Java最新2021年面试题附答案解析，大汇总

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)



### 1、UML中有哪些常用的图？



UML定义了多种图形化的符号来描述软件系统部分或全部的静态结构和动态结构，包括：用例图（use case diagram）、类图（class diagram）、时序图（sequence diagram）、协作图（collaboration diagram）、状态图（statechart diagram）、活动图（activity diagram）、构件图（component diagram）、部署图（deployment diagram）等。在这些图形化符号中，有三种图最为重要，分别是：用例图（用来捕获需求，描述系统的功能，通过该图可以迅速的了解系统的功能模块及其关系）、类图（描述类以及类与类之间的关系，通过该图可以快速了解系统）、时序图（描述执行特定任务时对象之间的交互关系以及执行顺序，通过该图可以了解对象能接收的消息也就是说对象能够向外界提供的服务）。

用例图：

![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2019/08/0816/03/img_6.png#alt=img%5C_6.png)

类图：

![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2019/08/0816/03/img_7.png#alt=img%5C_7.png)

时序图：

![](https://gitee.com/souyunkutech/souyunku-home/raw/master/images/souyunku-web/2019/08/0816/03/img_8.png#alt=img%5C_8.png)


### 2、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？



是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。在C#中可以编写如下所示的代码，但是在Java中却做不到。

```
using System;

namespace CS01 {

    class Program {
        public static void swap(ref int x, ref int y) {
            int temp = x;
            x = y;
            y = temp;
        }

        public static void Main (string[] args) {
            int a = 5, b = 10;
            swap (ref a, ref b);
            // a = 10, b = 5;
            Console.WriteLine ("a = {0}, b = {1}", a, b);
        }
    }
}
```

说明：

Java中没有传引用实在是非常的不方便，这一点在Java 8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。


### 3、Java中有几种数据类型

**1、** 整形：byte,short,int,long

**2、** 浮点型：float,double

**3、** 字符型：char

**4、** 布尔型：boolean


### 4、HashSet如何检查重复？HashSet是如何保证数据不可重复的？

**1、** 向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。

**2、** HashSet 中的add ()方法会使用HashMap 的put()方法。

**3、** HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。

**以下是HashSet 部分源码：**

```
private static final Object PRESENT = new Object();
private transient HashMap<E,Object> map;

public HashSet() {
map = new HashMap<>();
}

public boolean add(E e) {
// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值
return map.put(e, PRESENT)==null;
}
```

**hashCode（）与equals（）的相关规定**：

**1、** 如果两个对象相等，则hashcode一定也是相同的，hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值

**2、** 两个对象相等,对两个equals方法返回true

**3、** 两个对象有相同的hashcode值，它们也不一定是相等的

**4、** 综上，equals方法被覆盖过，则hashCode方法也必须被覆盖

**5、** hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。

**==与equals的区别**

**1、** ==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同

**2、** ==是指对内存地址进行比较 equals()是对字符串的内容进行比较


### 5、JAVA弱引用

弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。


### 6、使用js获取一个表单元素

**1、** Document.getElementById()

**2、** Document.getElementsByName()

**3、** Document.getElementsByTagName()


### 7、什么是happen-before原则？

单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。volatile的happen-before原则：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。线程中断的happen-before原则 ：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。


### 8、怎么确保一个集合不能被修改？

可以使用 Collections、unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java、lang、UnsupportedOperationException 异常。

**示例代码如下：**

```
List<String> list = new ArrayList<>();
list、add("x");
Collection<String> clist = Collections、unmodifiableCollection(list);
clist、add("y"); // 运行时此行报错
System、out、println(list、size());
```


### 9、Java 线程数过多会造成什么异常？

**1、** 线程的生命周期开销非常高

**2、** 消耗过多的 CPU

资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU资源时还将产生其他性能的开销。

**降低稳定性JVM**

在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。


### 10、线程的 sleep()方法和 yield()方法有什么区别？

**1、** sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；

**2、** 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；

**3、** sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；

**4、** sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。


### 11、java中会存在内存泄漏吗，请简单描述。
### 12、safepoint是什么？
### 13、synchronized、volatile、CAS比较
### 14、标记整理算法(Mark-Compact)
### 15、Java中你怎样唤醒一个阻塞的线程？
### 16、在异常捕捉时，如果发生异常，那么try.catch.finally块外的return语句会执行吗？
### 17、Java 中 sleep 方法和 wait 方法的区别？
### 18、插入数据时 ArrayList、LinkedList、Vector谁速度较快？
### 19、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？
### 20、什么是单例
### 21、对象分配内存是否线程安全？
### 22、谈谈永久代
### 23、GC 是什么? 为什么要有 GC
### 24、JIT 是什么？
### 25、Java的io流分为哪两种？
### 26、WeakHashMap 是怎么工作的？
### 27、详细介绍一下JVM内存模型
### 28、如何判断一个对象是否存活
### 29、实例化数组后，能不能改变数组长度呢？
### 30、JVM有哪些内存区域？(JVM的内存布局是什么？)
### 31、Java 中的 HashSet，内部是如何工作的？
### 32、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？
### 33、说一下 runnable 和 callable 有什么区别
### 34、阐述Spring框架中Bean的生命周期？
### 35、i与i的区别
### 36、说出至少 5 点在 Java 中使用线程的最佳实践。
### 37、为什么wait, notify 和 notifyAll这些方法不在thread类里面？
### 38、Java中各种数据默认值
### 39、synchronized 和 ReentrantLock 区别是什么？
### 40、为什么HashMap中String、Integer这样的包装类适合作为K？
### 41、垃圾回收的优点和原理。说说2种回收机制




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "大厂面试题")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png"大厂面试题")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
