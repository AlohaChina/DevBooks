# Java面试题目大汇总，附参考答案

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://github.com/souyunku/DevBooks/blob/master/docs/index.md)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png)



### 1、多线程中 synchronized 锁升级的原理是什么？

synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。

**锁的升级的目的：**

锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。

**1、** 偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。

**2、** 轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，轻量级锁就会升级为重量级锁；

**3、** 重量级锁是synchronized ，是 Java 虚拟机中最为基础的锁实现。在这种状态下，Java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。

### 2、java 中操作字符串都有哪些类？它们之间有什么区别？

操作字符串的类有：String、StringBuffer、StringBuilder。

String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。

StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。


### 3、url是什么？由哪些部分组成？

统一资源定位符

http://localhost:8080/myWeb/index.html：协议+主机地址+端口+项目名称+资源名称


### 4、类加载有几个过程？

加载、验证、准备、解析、初始化。


### 5、死锁与活锁的区别，死锁与饥饿的区别？

死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

**产生死锁的必要条件**：

**1、** 互斥条件：所谓互斥就是进程在某一时间内独占资源。

**2、** 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

**3、** 不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。

**4、** 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

**活锁**：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。

活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。

**饥饿**：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。

**Java中导致饥饿的原因**：

**1、** 高优先级线程吞噬所有的低优先级线程的CPU时间。

**2、** 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。

**3、** 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。


### 6、线程类的构造方法、静态块是被哪个线程调用的

这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。

如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：

**1、** Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的

**2、** Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的


### 7、遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？

**遍历方式有以下几种：**

**1、** for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。

**2、** 迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。

**3、** foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。

**最佳实践：**

Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。

**1、** 如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。

**2、** 如果没有实现该接口，表示不支持 Random Access，如LinkedList。

**3、** 推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。


### 8、Java 内存分配

寄存器：我们无法控制。

静态域：static定义的静态成员。

常量池：编译时被确定并保存在 .class 文件中的（final）常量值和一些文本修饰的符号引用（类和接口的全限定名，字段的名称和描述符，方法和名称和描述符）。

非 RAM 存储：硬盘等永久存储空间。

堆内存：new 创建的对象和数组，由 Java 虚拟机自动垃圾回收器管理,存取速度慢。

栈内存：基本类型的变量和对象的引用变量（堆内存空间的访问地址），速度快，可以共享，但是大小与生存期必须确定，缺乏灵活性。


### 9、死锁的原因

**1、** 是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环。

例如：线程在获得了锁A并且没有释放的情况下去申请锁B，这时，另一个线程已经获得了锁B，在释放锁B之前又要先获得锁A，因此闭环发生，陷入死锁循环。

**2、** 默认的锁申请操作是阻塞的。

所以要避免死锁，就要在一遇到多个对象锁交叉的情况，就要仔细审查这几个对象的类中的所有方法，是否存在着导致锁依赖的环路的可能性。总之是尽量避免在一个同步方法中调用其它对象的延时方法和同步方法。


### 10、Session加载实体对象的过程。

**1、** Session在调用数据库查询功能之前，首先会在一级缓存中通过实体类型和主键进行查找，如果一级缓存查找命中且数据状态合法，则直接返回；

**2、** 如果一级缓存没有命中，接下来Session会在当前NonExists记录（相当于一个查询黑名单，如果出现重复的无效查询可以迅速做出判断，从而提升性能）中进行查找，如果NonExists中存在同样的查询条件，则返回null；

**3、** 如果一级缓存查询失败则查询二级缓存，如果二级缓存命中则直接返回；

**4、** 如果之前的查询都未命中，则发出SQL语句，如果查询未发现对应记录则将此次查询添加到Session的NonExists中加以记录，并返回null；

**5、** 根据映射配置和SQL语句得到ResultSet，并创建对应的实体对象；

**6、** 将对象纳入Session（一级缓存）的管理；

**7、** 如果有对应的拦截器，则执行拦截器的onLoad方法；

**8、** 如果开启并设置了要使用二级缓存，则将数据对象纳入二级缓存；

**9、** 返回数据对象。


### 11、synchronized关键字的用法？
### 12、栈溢出的原因？
### 13、运行时异常与受检异常有何异同？
### 14、哪些是 GC Roots？
### 15、列举一些你知道的打破双亲委派机制的例子。为什么要打破？
### 16、redux与mobx的区别?
### 17、什么情况下会违反迪米特法则？为什么会有这个问题？
### 18、G1 收集器
### 19、Java 中会存在内存泄漏?简述一下
### 20、创建一个子类对象的时候，那么父类的构造方法会执行吗？
### 21、多线程同步和互斥有几种实现方法，都是什么？
### 22、动态改变构造
### 23、什么是线程组，为什么在Java中不推荐使用？
### 24、你如何在Java中获取线程堆栈？
### 25、请说出与线程同步以及线程调度相关的方法。
### 26、HTTP的状态码
### 27、volatile有什么用？能否用一句话说明下volatile的应用场景？
### 28、存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么？如 C = (C) B；
### 29、Java 线程数过多会造成什么异常？
### 30、Spring MVC的工作原理是怎样的？
### 31、Java中如何实现序列化，有什么意义？
### 32、JDK 和 JRE 有什么区别？
### 33、如何停止一个正在运行的线程？
### 34、什么是FutureTask?使用ExecutorService启动任务。
### 35、redux的工作流程?
### 36、简述一下你了解的设计模式。
### 37、适配器模式和装饰器模式有什么区别？
### 38、说一下 runnable 和 callable 有什么区别
### 39、synchronized 和 volatile 的区别是什么？
### 40、redux中如何进行异步操作?




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin-2.png)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
