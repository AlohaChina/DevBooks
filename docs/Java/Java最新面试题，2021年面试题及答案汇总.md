# Java最新面试题，2021年面试题及答案汇总

### 其实，博主还整理了，更多大厂面试题，直接下载吧

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)



### 1、redux与mobx的区别?

**两者对比:**

**1、** redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中

**2、** redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存数据，数据变化后自动处理响应的操作

**3、** redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改

**4、** mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用

**5、** mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易

**场景辨析:**

基于以上区别,我们可以简单得分析一下两者的不同使用场景.

mobx更适合数据不复杂的应用: mobx难以调试,很多状态无法回溯,面对复杂度高的应用时,往往力不从心.

redux适合有回溯需求的应用: 比如一个画板应用、一个表格应用，很多时候需要撤销、重做等操作，由于redux不可变的特性，天然支持这些操作.

mobx适合短平快的项目: mobx上手简单,样板代码少,可以很大程度上提高开发效率.

当然mobx和redux也并不一定是非此即彼的关系,你也可以在项目中用redux作为全局状态管理,用mobx作为组件局部状态管理器来用.


### 2、什么是集合

**1、** 集合就是一个放数据的容器，准确的说是放数据对象引用的容器

**2、** 集合类存放的都是对象的引用，而不是对象的本身

**3、** 集合类型主要有3种：set(集）、list(列表）和map(映射)。


### 3、为什么 ArrayList 的 elementData 加上 transient 修饰？

ArrayList 中的数组定义如下：

`private transient Object\[\] elementData;`

**再看一下 ArrayList 的定义：**

```
public class ArrayList<E> extends AbstractList<E>
implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。transient 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现：

```
private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{
*// Write out element count, and any hidden stuff*
int expectedModCount = modCount;
s.defaultWriteObject();
*// Write out array length*
s.writeInt(elementData.length);
*// Write out all elements in the proper order.*
for (int i=0; i<size; i++)
s.writeObject(elementData[i]);
if (modCount != expectedModCount) {
throw new ConcurrentModificationException();
}
```

每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。


### 4、==与equlas有什么区别？

==可以判断基本数据类型值是否相等，也可以判断两个对象指向的内存地址是否相同，也就是说判断两个对象是否是同一个对象，Equlas通常用来做字符串比较。


### 5、什么是自旋

很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。

忙循环：就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。


### 6、String类的常用方法有那些？

**1、** charAt：返回指定索引处的字符

**2、** indexOf()：返回指定字符的索引

**3、** replace()：字符串替换

**4、** trim()：去除字符串两端空白

**5、** split()：分割字符串，返回一个分割后的字符串数组

**6、** getBytes()：返回字符串的byte类型数组

**7、** length()：返回字符串长度

**8、** toLowerCase()：将字符串转成小写字母

**9、** toUpperCase()：将字符串转成大写字符

**10、** substring()：截取字符串

**11、** format()：格式化字符串

**12、** equals()：字符串比较


### 7、什么是内存屏障？

内存屏障，也叫内存栅栏，是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。


### 8、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？

不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。


### 9、sleep() 和 wait() 有什么区别？

两者都可以暂停线程的执行

**1、** 类的不同：

sleep() 是 Thread线程类的静态方法，wait() 是 Object类的方法。

**2、** 是否释放锁：

sleep() 不释放锁；wait() 释放锁。

**3、** 用途不同：

Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。

**4、** 用法不同：

wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。


### 10、Java 中，怎么获取一个文件中单词出现的最高频率？

解决方案

[http://java67.blogspot.com/2015/10/java-program-to-find-repeated-words-and-count.html](http://java67.blogspot.com/2015/10/java-program-to-find-repeated-words-and-count.html)


### 11、Java 中，抽象类与接口之间有什么不同？
### 12、形参与实参
### 13、如何在 Windows 和 Linux 上查找哪个线程cpu利用率最高？
### 14、字符型常量和字符串常量的区别
### 15、类加载器双亲委派模型机制？
### 16、什么是线程死锁
### 17、什么是模板方法模式？
### 18、你是如何调用 wait() 方法的？使用 if 块还是循环？为什么？
### 19、线程之间如何通信及线程之间如何同步
### 20、多线程的常用方法
### 21、Collection接口下有那些集合框架？
### 22、本地方法区(线程私有)
### 23、你知道哪些垃圾收集器？
### 24、43.将下java中的math类有那些常用方法？
### 25、String str="i"与 String str=new String("i")一样吗？
### 26、方法区/永久代（线程共享）
### 27、线程B怎么知道线程A修改了变量
### 28、什么是多线程
### 29、什么是数据结构？
### 30、简述synchronized 和java.util.concurrent.locks.Lock的异同？
### 31、常用io类有那些？
### 32、如何写一段简单的死锁代码？
### 33、说说类加载的过程
### 34、如何用Java代码列出一个目录下所有的文件？
### 35、为什么要学习工厂设计模式
### 36、什么是多态机制？Java语言是如何实现多态的？
### 37、依赖注入和工程模式之间有什么不同？
### 38、什么是ThreadLocal变量？
### 39、类的实例化顺序
### 40、Sql优化有那些方法？
### 41、描述一下什么情况下，对象会从年轻代进入老年代




## 全部答案，整理好了，直接下载吧

### 下载链接：[全部答案，整理好了](https://www.souyunku.com/?p=67)

### 一键直达：[https://www.souyunku.com/?p=67](https://www.souyunku.com/?p=67)


## 最新，高清PDF：172份，7701页，最新整理

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/mst.png "大厂面试题")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png"大厂面试题")

[![大厂面试题](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")](https://www.souyunku.com/wp-content/uploads/weixin/githup-weixin.png "架构师专栏")
